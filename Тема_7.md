# Тема 7. Работа с файлами (ввод, вывод).

Отчет по Теме 7 выполнил(а):

- Рублев Валерий Игоревич
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | + | 
| Задание 7 | + | 
| Задание 8 | + | 
| Задание 9 | + | 
| Задание 10 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Составьте текстовый файл и положите его в одну директорию с программой на Python. Текстовый файл должен состоять минимум из двух строк.
```python
# Создаем текстовый файл и записываем в него две строки
with open('мой_текстовый_файл.txt', 'w') as file:
    file.write('Это первая строка текстового файла.\n')
    file.write('А это вторая строка.')
# Подтверждение создания и записи файла
print('Текстовый файл создан и заполнен.')
# Дополнительно, вы можете вывести содержимое файла для проверки
with open('мой_текстовый_файл.txt', 'r') as file:
    content = file.read()
    print('Содержимое файла:')
    print(content)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab1.png)
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab1.1.png)
## Выводы
В данном коде.
Этот код выполняет следующие действия:
1.Создает текстовый файл с именем "мой_текстовый_файл.txt" в режиме записи ('w').
2.Записывает две строки в этот файл: "Это первая строка текстового файла." и "А это вторая строка." Строки разделяются символом новой строки '\n'.
3.Выводит сообщение "Текстовый файл создан и заполнен." для подтверждения успешного создания и записи файла.
4.Дополнительно, читает содержимое файла, используя режим чтения ('r'), и выводит его на экран, предварительно добавив заголовок "Содержимое файла:".
Результат выполнения кода будет следующим:
```
Текстовый файл создан и заполнен.
Содержимое файла:
Это первая строка текстового файла.
А это вторая строка.
Таким образом, код создает текстовый файл, записывает в него две строки текста, подтверждает выполнение операции и выводит содержимое файла на экран для проверки.
```
### Создаем текстовый файл и записываем в него две строки
with open('мой_текстовый_файл.txt', 'w') as file:
    file.write('Это первая строка текстового файла.\n')
    file.write('А это вторая строка.')
### Подтверждение создания и записи файла
print('Текстовый файл создан и заполнен.')
### Дополнительно, вы можете вывести содержимое файла для проверки
with open('мой_текстовый_файл.txt', 'r') as file:
    content = file.read()
    print('Содержимое файла:')
    print(content)

# Лабороторная работа№2
### Напишите программу, которая выведет только первую строку из вашего файла, при этом используйте конструкцию open()/close(). 
```python
f = open('lab1.txt', 'r')
print(f.readline())
f.close()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab2.png)
## Выводы
В данном коде. 
Этот код выполняет следующие действия:
1.Открывает файл с именем 'lab1.txt' в режиме чтения ('r') и связывает его с переменной f.
2.Считывает первую строку из открытого файла с помощью метода readline() и выводит ее на экран с помощью функции print().
3.Закрывает файл с помощью метода close().
Когда код выполняется, он открывает файл 'lab1.txt', читает первую строку из файла и выводит ее на экран. Затем файл закрывается. Если в файле есть более одной строки, этот код выведет только первую строку. Если файла не существует или возникнут проблемы при открытии файла, может возникнуть исключение.

### Открываем файл 'lab1.txt' в режиме чтения ('r') и связываем его с переменной `f`
f = open('lab1.txt', 'r')
### Считываем первую строку из открытого файла и выводим ее на экран
print(f.readline())
### Закрываем файл
f.close()

# Лабороторная работа№3
### Напишите программу, которая выведет все строки из вашего файла в массиве, при этом используйте конструкцию open()/close(). 
```python
f = open('lab1.txt', 'r')
print(f.readlines())
f.close()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab3.png)
## Выводы
В данном коде. 
Этот код выполняет следующие действия:
С помощью комментария указывается, что открывается файл 'lab1.txt' в режиме чтения и связывается с переменной f.
Считываются все строки из открытого файла с использованием метода readlines(), и они выводятся на экран в виде списка строк.
Закрывается файл с помощью метода close().

### Открываем файл 'lab1.txt' в режиме чтения ('r') и связываем его с переменной `f`
f = open('lab1.txt', 'r')
### Считываем все строки из открытого файла и выводим их в виде списка на экран
print(f.readlines())
### Закрываем файл
f.close()

# Лабороторная работа№4
### Напишите программу, которая выведет все строки из вашего файла в массиве, при этом используйте конструкцию with open(). 
```python
with open('lab1.txt') as f:
    print(f.readlines())
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab4.png)
## Выводы
В данном коде. 
Этот код выполняет следующие действия:
1.С помощью комментария указывается, что файл 'lab1.txt' открывается в режиме чтения с использованием оператора with. Это гарантирует автоматическое закрытие файла после выполнения блока кода, что является хорошей практикой.
2.Считываются все строки из открытого файла с использованием метода readlines(), и они выводятся на экран в виде списка строк. Каждая строка файла представляется отдельным элементом в списке.
3.После выполнения блока кода, файл автоматически закрывается, так как он был открыт с использованием оператора with.

### Открываем файл 'lab1.txt' в режиме чтения с использованием оператора 'with',
### что автоматически закроет файл после выполнения блока кода
with open('lab1.txt') as f:
    ### Считываем все строки из открытого файла и выводим их в виде списка на экран
    print(f.readlines())

# Лабороторная работа№5
### Напишите программу, которая выведет каждую строку из вашего файла отдельно, при этом используйте конструкцию with open(). 
```python
with open('lab1.txt') as f:
    for line in f:
        print(line)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab5.png)
## Выводы
В данном коде. 
Этот код выполняет следующие действия:
1.С помощью комментария указывается, что файл 'lab1.txt' открывается в режиме чтения с использованием оператора with. Это гарантирует автоматическое закрытие файла после выполнения блока кода, что является хорошей практикой.
2.В цикле for, проходящем через каждую строку в открытом файле, каждая строка файла выводится на экран с использованием функции print().
3.После выполнения блока кода, файл автоматически закрывается, так как он был открыт с использованием оператора with.

### Открываем файл 'lab1.txt' в режиме чтения с использованием оператора 'with',
### что автоматически закроет файл после выполнения блока кода
with open('lab1.txt') as f:
    ### Итерируемся по каждой строке в открытом файле
    for line in f:
        ### Выводим каждую строку на экран
        print(line)


# Лабороторная работа№6
### Напишите программу, которая будет добавлять новую строку в ваш E:\Python\lab7\lab1.txt файл, а потом выведет полученный файл в консоль. Вывод можно осуществлять любым способом. Обязательно проверьте сам файл, чтобы изменения в нем тоже отображались. 
```python
with open('lab1.txt', 'a+') as f:
    f.write('\nIm additional line')
with open('lab1.txt' , 'r') as f:
    result = f.readlines()
    print(result)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab6.png)
## Выводы
В данном коде. 
Этот код выполняет следующие действия:
1.С помощью комментария указывается, что файл 'lab1.txt' открывается в режиме добавления ('a+'). Это позволяет открыть файл для записи с возможностью чтения и автоматически закрыть его после выполнения блока кода.
2.В файл добавляется строка '\nIm additional line' с помощью метода write(), что создает дополнительную строку в файле.
3.Затем файл снова открывается в режиме чтения ('r') с использованием оператора with.
4.Считываются все строки из открытого файла с использованием метода readlines() и сохраняются в переменной 'result'.
5.Содержимое файла, включая добавленную строку, выводится на экран с помощью функции print().
После выполнения кода, содержимое файла 'lab1.txt', включая добавленную строку, будет выведено на экран.

### Открываем файл 'lab1.txt' в режиме добавления ('a+') с использованием оператора 'with',
### что автоматически закроет файл после выполнения блока кода
with open('lab1.txt', 'a+') as f:
    ### Записываем строку '\nIm additional line' в файл (добавляем дополнительную строку)
    f.write('\nIm additional line')
### Открываем файл 'lab1.txt' в режиме чтения ('r') с использованием оператора 'with'
with open('lab1.txt', 'r') as f:
    ### Считываем все строки из открытого файла и сохраняем их в переменной 'result'
    result = f.readlines()
    ### Выводим содержимое файла на экран
    print(result)



# Лабороторная работа№7
### Напишите программу, которая перепишет всю информацию, которая была у вас в файле до этого, например напишет любые данные из произвольно вами составленного списка. Также не забудьте проверить что измененная вами информация сохранилась в файле. 
```python
lines = ['one', 'two', 'three']
with open('lab1.txt', 'w') as f:
    for line in lines:
        f.write('\nCycle run' + line)
        print('Done!')
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab7.png)
## Выводы
В данном коде. 
Этот код выполняет следующие действия:
1.Задается список строк lines, содержащий три строки: 'one', 'two' и 'three'.
2.Открывается файл 'lab1.txt' в режиме записи ('w') с использованием оператора with, что автоматически закроет файл после выполнения блока кода.
3.В цикле for, проходящем через каждую строку в списке lines, каждая строка дополняется строкой 'Cycle run' и записывается в файл с использованием метода write(). После этого выводится сообщение 'Done!' на экран для каждой итерации цикла.
После выполнения кода, файл 'lab1.txt' будет содержать четыре строки: 'Cycle runone', 'Cycle runtwo', 'Cycle runthree', и каждое выполнение цикла будет сопровождаться сообщением 'Done!' на экране.

### Задаем список строк 'lines'
lines = ['one', 'two', 'three']
### Открываем файл 'lab1.txt' в режиме записи ('w') с использованием оператора 'with',
### что автоматически закроет файл после выполнения блока кода
with open('lab1.txt', 'w') as f:
    ### В цикле 'for', проходящем через каждую строку в списке 'lines'
    for line in lines:
        ### Записываем в файл строку 'Cycle run' + текущая строка из списка
        f.write('\nCycle run' + line)
        ### Выводим 'Done!' на экран для каждой итерации цикла
        print('Done!')

# Лабороторная работа№8
### Выберите любую папку на своем компьютере, имеющую вложенные директории. Выведите на печать в терминал ее содержимое, как и всех подкаталогов при помощи функции print_docs(directory). 
```python
import os
def print_docs(directory):
    all_files = os.walk(directory)
    for catalog in all_files:
        print(f"Папка {catalog[0]} содержит:")
        print(f'Деректории: {", ".join([folder for folder in catalog[1]])}')
        print(f'Файлы: {", ".join([folder for folder in catalog[2]])}')
        print('-' * 40)
print_docs('C:/Users/user/Desktop/LAB')
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab8.png)
## Выводы
В данном коде. 
Этот код выполняет следующие действия:
1.Импортируется модуль os, который предоставляет функциональность для работы с операционной системой.
2.Определяется функция print_docs, которая принимает путь к директории в качестве аргумента.
3.Внутри функции используется os.walk(directory), чтобы получить информацию о всех файлах и папках в указанной директории и её поддиректориях. Результат os.walk представляет собой итерируемый объект, содержащий кортежи с информацией о каждой директории.
4.Для каждой найденной директории и её содержимого выводится информация на экран: имя папки, список поддиректорий и список файлов.
5.Разделительная строка из символов '-' помогает отделить информацию о разных директориях.
6.Функция print_docs вызывается с указанным путем к директории, и информация о содержимом этой директории и её поддиректориях выводится на экран.

### Импортируем модуль 'os' для работы с операционной системой
import os
### Определяем функцию 'print_docs', которая принимает директорию в качестве аргумента
def print_docs(directory):
    ### Получаем информацию о всех файлах и папках в указанной директории и её поддиректориях
    all_files = os.walk(directory)
    ### Для каждой найденной директории и её содержимого
    for catalog in all_files:
        ### Выводим информацию о текущей папке
        print(f"Папка {catalog[0]} содержит:")
        ### Выводим список поддиректорий
        print(f'Директории: {", ".join([folder for folder in catalog[1]])}')
        ### Выводим список файлов
        print(f'Файлы: {", ".join([folder for folder in catalog[2]])}')
        ### Выводим разделительную строку
        print('-' * 40)
### Вызываем функцию 'print_docs' и передаем ей путь к директории
print_docs('C:/Users/user/Desktop/LAB')

# Лабороторная работа№9
### Документ «input.txt» содержит следующий текст: 
Приветствие 
Спасибо 
Извините
Пожалуйста 
До свидания 
Ты готов? 
Как дела? 
С днем рождения! 
Удача! 
Я тебя люблю. 
Требуется реализовать функцию, которая выводит слово, имеющее максимальную длину (или список слов, если таковых несколько). Проверьте работоспособность программы на своем наборе данных 
```python
def longest_words(file):
    with open(file, encoding='utf-8') as f:
        words = f.read().split()
        max_length = len(max(words, key=len))
        for word in words:
            if len(word) == max_length:
                sought_words = word
        if len(sought_words) == 1:
            return sought_words[0]
        return sought_words
print(longest_words('lab1.txt'))
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab9.png)
## Выводы
В данном коде. 
Основная идея кода - найти самые длинные слова в текстовом файле и вернуть их. Ошибки, которые могут возникнуть при выполнении кода:
1.sought_words следует инициализировать пустым списком, а не пустой строкой, чтобы в него можно было добавлять найденные слова.
2.В строке return sought_words[0] нужно вернуть первый элемент списка, если он существует. Иначе, если sought_words пустой, возможно, следует вернуть None или какое-то другое значение по умолчанию, чтобы избежать ошибок.

### Определение функции `longest_words`, которая принимает путь к файлу в качестве аргумента
def longest_words(file):
    ### Открываем файл для чтения с указанием кодировки utf-8
    with open(file, encoding='utf-8') as f:
        ### Считываем содержимое файла и разбиваем его на слова, разделенные пробелами
        words = f.read().split()
        ### Находим длину самого длинного слова в списке `words`
        max_length = len(max(words, key=len))
        ### Инициализируем переменную `sought_words` для хранения самых длинных слов
        sought_words = []
        ### Перебираем все слова в списке `words`
        for word in words:
            ### Если длина текущего слова равна максимальной длине, добавляем его в `sought_words`
            if len(word) == max_length:
                sought_words.append(word)
        ### Если в `sought_words` есть только одно слово, возвращаем его
        if len(sought_words) == 1:
            return sought_words[0]
        ### В противном случае возвращаем список самых длинных слов
        return sought_words
### Вызываем функцию `longest_words` с указанным файлом 'lab1.txt' и выводим результат
print(longest_words('lab1.txt'))

# Лабороторная работа№10
### Требуется создать csv-файл «rows_300.csv» со следующими столбцами: 
· № - номер по порядку (от 1 до 300);
· Секунда – текущая секунда на вашем ПК; 
· Микросекунда – текущая миллисекунда на часах. 
Для наглядности на каждой итерации цикла искусственно приостанавливайте скрипт на 0,01 секунды. 
```python
import csv
import datetime
import time
with open('rows_300.csv', 'w', encoding='utf-8', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(['№', 'Секунда', 'Микросекунда'])
    for line in range(1, 301):
        writer.writerow([line, datetime.datetime.now().second, datetime.datetime.now().microsecond])
        time.sleep(0.01)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/lab10.png)
## Выводы
В данном коде. 
Этот код создает файл 'rows_300.csv', записывает в него 300 строк данных, каждая из которых содержит номер, текущую секунду и текущие микросекунды времени. Между записями данных вставляется задержка в 0.01 секунды с помощью time.sleep(0.01).

### Импортируем модуль csv для работы с CSV-файлами
import csv
### Импортируем модуль datetime для работы с датой и временем
import datetime
### Импортируем модуль time для создания задержки
import time
### Открываем файл 'rows_300.csv' для записи (создание нового файла или перезапись существующего)
### с указанием кодировки utf-8 и опции newline='' для корректной обработки строк в CSV-файле
with open('rows_300.csv', 'w', encoding='utf-8', newline='') as f:
    ### Создаем объект writer для записи данных в CSV-файл
    writer = csv.writer(f)
    ### Записываем заголовок (заголовок таблицы) в CSV-файл
    writer.writerow(['№', 'Секунда', 'Микросекунда'])
    ### В цикле генерируем 300 строк данных
    for line in range(1, 301):
        ### Получаем текущую секунду и микросекунду с использованием модуля datetime
        current_time = datetime.datetime.now()
        second = current_time.second
        microsecond = current_time.microsecond
        ### Записываем данные в текущей строке CSV-файла
        writer.writerow([line, second, microsecond])
        ### Создаем задержку в 0.01 секунды (10 миллисекунд) перед записью следующей строки
        time.sleep(0.01)

# Самостоятельная работа№1
### Найдите в интернете любую статью (объем статьи не менее 200 слов), скопируйте ее содержимое в файл и напишите программу, которая считает количество слов в текстовом файле и определит самое часто встречающееся слово. Результатом выполнения задачи будет: скриншот файла со статьей, листинг кода, и вывод в консоль, в котором будет указана вся необходимая информация. 
```python
import re
from collections import Counter
# Функция для подсчета количества слов в файле
def count_words(filename):
    with open(filename, 'r', encoding='utf-8') as file:
        text = file.read()
        words = re.findall(r'\w+', text)
        return len(words)
# Функция для определения самого часто встречающегося слова
def most_common_word(filename):
    with open(filename, 'r', encoding='utf-8') as file:
        text = file.read()
        words = re.findall(r'\w+', text)
        word_counts = Counter(words)
        most_common = word_counts.most_common(1)
        return most_common[0]
# Замените 'your_file.txt' на путь к вашему текстовому файлу
file_path = 'your_file.txt'
total_words = count_words(file_path)
most_common = most_common_word(file_path)
print(f"Общее количество слов в файле: {total_words}")
print(f"Самое часто встречающееся слово: '{most_common[0]}' (встречается {most_common[1]} раз)")
# Если вы хотите сохранить результаты в файл, вы можете сделать это следующим образом:
# with open('results.txt', 'w', encoding='utf-8') as result_file:
#     result_file.write(f"Общее количество слов в файле: {total_words}\n")
#     result_file.write(f"Самое часто встречающееся слово: '{most_common[0]}' (встречается {most_common[1]} раз)\n")
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/sam1.png)
## Выводы
В данном коде.  
Код, который вы предоставили, выполняет две задачи:
1.count_words(filename): Эта функция открывает файл с заданным именем, считывает его содержимое и использует регулярное выражение для подсчета количества слов в тексте.
2.most_common_word(filename): Эта функция также открывает файл с заданным именем, считывает его содержимое, использует регулярное выражение для разделения текста на слова и затем использует модуль collections для подсчета самого часто встречающегося слова в тексте.
Затем код выводит результаты в консоль.

### Импортируем модуль re для работы с регулярными выражениями
import re
### Импортируем класс Counter из модуля collections для подсчета элементов
from collections import Counter
### Функция для подсчета количества слов в файле
def count_words(filename):
    with open(filename, 'r', encoding='utf-8') as file:
        text = file.read()
        ### Используем регулярное выражение, чтобы найти все слова в тексте
        words = re.findall(r'\w+', text)
        return len(words)
### Функция для определения самого часто встречающегося слова
def most_common_word(filename):
    with open(filename, 'r', encoding='utf-8') as file:
        text = file.read()
        ### Используем регулярное выражение, чтобы найти все слова в тексте
        words = re.findall(r'\w+', text)
        ### Создаем объект Counter для подсчета слов
        word_counts = Counter(words)
        ### Получаем самое часто встречающееся слово и его количество
        most_common = word_counts.most_common(1)
        return most_common[0]
### Указываем путь к текстовому файлу, который вы хотите анализировать
file_path = 'your_file.txt'
### Вызываем функции для анализа файла
total_words = count_words(file_path)
most_common = most_common_word(file_path)
### Выводим результаты в консоль
print(f"Общее количество слов в файле: {total_words}")
print(f"Самое часто встречающееся слово: '{most_common[0]}' (встречается {most_common[1]} раз)")
### Если вы хотите сохранить результаты в файл, вы можете использовать следующий код:
### with open('results.txt', 'w', encoding='utf-8') as result_file:
###     result_file.write(f"Общее количество слов в файле: {total_words}\n")
###     result_file.write(f"Самое часто встречающееся слово: '{most_common[0]}' (встречается {most_common[1]} раз)\n")




# Самостоятельная работа№2
### У вас появилась потребность в ведении книги расходов, посмотрев все существующие варианты вы пришли к выводу что вас ничего не устраивает и нужно все делать самому. Напишите программу для учета расходов. Программа должна позволять вводить информацию о расходах, сохранять ее в файл и выводить существующие данные в консоль. Ввод информации происходит через консоль. Результатом выполнения задачи будет: скриншот файла с учетом расходов, листинг кода, и вывод в консоль, с демонстрацией работоспособности программы. 
```python
import json  # Импорт модуля json для работы с данными в формате JSON.
from datetime import datetime  # Импорт модуля datetime для получения текущей даты и времени.
# Функция для добавления расходов в список.
def add_expense(expenses, category, amount):
    # Получение текущей метки времени и форматирование её как 'ГГГГ-ММ-ДД ЧЧ:мм:сс'.
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    # Добавление информации о расходе в список expenses.
    expenses.append({'timestamp': timestamp, 'category': category, 'amount': amount})
# Функция для сохранения расходов в файл в формате JSON.
def save_expenses(expenses, filename):
    with open(filename, 'w', encoding='utf-8') as file:
        # Запись списка расходов в файл в формате JSON.
        json.dump(expenses, file, ensure_ascii=False, indent=2)
# Функция для вывода расходов в консоль.
def display_expenses(expenses):
    for expense in expenses:
        # Вывод на экран метки времени, категории и суммы каждого расхода.
        print(f"{expense['timestamp']} - {expense['category']}: ${expense['amount']}")
# Указание имени файла, в котором будут храниться расходы (замените 'expenses.json' на ваше желаемое имя файла).
expenses_filename = 'expenses.json'
# Инициализация пустого списка для хранения расходов.
expenses = []
# Основной цикл программы.
while True:
    print("\n1. Добавить расход")  # Опция для добавления расхода.
    print("2. Показать расходы")  # Опция для отображения расходов.
    print("3. Выход")  # Опция для завершения программы.
    # Запрос выбора пользователя (1, 2 или 3).
    choice = input("Выберите действие (1/2/3): ")
    if choice == '1':  # Если пользователь выбирает добавить расход.
        category = input("Введите категорию расхода: ")  # Запрос о категории расхода.
        amount = float(input("Введите сумму расхода: "))  # Запрос о сумме расхода.
        add_expense(expenses, category, amount)  # Вызов функции для добавления расхода.
        save_expenses(expenses, expenses_filename)  # Сохранение расходов в файл.
        print("Расход успешно добавлен!")  # Отображение сообщения об успешном добавлении.
    elif choice == '2':  # Если пользователь выбирает отобразить расходы.
        if not expenses:
            print("Нет сохраненных расходов.")  # Если в списке нет расходов.
        else:
            print("\nСуществующие расходы:")  # Если в списке есть расходы.
            display_expenses(expenses)  # Вызов функции для отображения расходов.
    elif choice == '3':  # Если пользователь выбирает завершить программу.
        print("Программа завершена.")  # Отображение сообщения о завершении.
        break  # Выход из цикла.
    else:  # Если пользователь вводит некорректный выбор.
        print("Некорректный выбор. Пожалуйста, выберите 1, 2 или 3.")  # Отображение сообщения об ошибке.
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/sam2.png)
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/sam2.1.png)
## Выводы
В данном коде. 
Этот код предоставляет простую программу для отслеживания расходов с опциями добавления, отображения и сохранения расходов в файле формата JSON. Пользователь взаимодействует с программой через консольное меню.

### Импорт модуля json для работы с данными в формате JSON.
import json  
from datetime import datetime  # Импорт модуля datetime для получения текущей даты и времени.
### Функция для добавления расходов в список.
def add_expense(expenses, category, amount):
    # Получение текущей метки времени и форматирование её как 'ГГГГ-ММ-ДД ЧЧ:мм:сс'.
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    ### Добавление информации о расходе в список expenses.
    expenses.append({'timestamp': timestamp, 'category': category, 'amount': amount})
### Функция для сохранения расходов в файл в формате JSON.
def save_expenses(expenses, filename):
    with open(filename, 'w', encoding='utf-8') as file:
        ### Запись списка расходов в файл в формате JSON.
        json.dump(expenses, file, ensure_ascii=False, indent=2)
### Функция для вывода расходов в консоль.
def display_expenses(expenses):
    for expense in expenses:
        # Вывод на экран метки времени, категории и суммы каждого расхода.
        print(f"{expense['timestamp']} - {expense['category']}: ${expense['amount']}")
### Указание имени файла, в котором будут храниться расходы (замените 'expenses.json' на ваше желаемое имя файла).
expenses_filename = 'expenses.json'
### Инициализация пустого списка для хранения расходов.
expenses = []
### Основной цикл программы.
while True:
    print("\n1. Добавить расход")  # Опция для добавления расхода.
    print("2. Показать расходы")  # Опция для отображения расходов.
    print("3. Выход")  # Опция для завершения программы.
    ### Запрос выбора пользователя (1, 2 или 3).
    choice = input("Выберите действие (1/2/3): ")
    ### Если пользователь выбирает добавить расход.
    if choice == '1':  
        ### Запрос о категории расхода.
        category = input("Введите категорию расхода: ")  
        ### Запрос о сумме расхода.
        amount = float(input("Введите сумму расхода: "))  
        ### Вызов функции для добавления расхода.
        add_expense(expenses, category, amount)  
        ### Сохранение расходов в файл.
        save_expenses(expenses, expenses_filename)  
        ### Отображение сообщения об успешном добавлении.
        print("Расход успешно добавлен!")  
###Если пользователь выбирает отобразить расходы.
    elif choice == '2':  
        if not expenses:
            ### Если в списке нет расходов.
            print("Нет сохраненных расходов.")  
        else:
            ### Если в списке есть расходы.
            print("\nСуществующие расходы:")  
            ### Вызов функции для отображения расходов.
            display_expenses(expenses)  
    ### Если пользователь выбирает завершить программу.
    elif choice == '3':  
        ### Отображение сообщения о завершении.
        print("Программа завершена.")  
        ### Выход из цикла.
        break  
    ### Если пользователь вводит некорректный выбор.
    else:
        ### Отображение сообщения об ошибке.
        print("Некорректный выбор. Пожалуйста, выберите 1, 2 или 3.")  

# Самостоятельная работа№3
### Имеется файл input.txt с текстом на латинице. Напишите программу, которая выводит следующую статистику по тексту: количество букв латинского алфавита; число слов; число строк. 
· Текст в файле: Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. 
Complex is better than complicated. · Ожидаемый результат: 
Input file contains: 108 letters 
20 words 4 lines 
```python
# Функция для подсчета количества букв латинского алфавита
def count_letters(text):
    return sum(c.isalpha() and c.isascii() for c in text)
# Функция для подсчета количества слов
def count_words(text):
    return len(text.split())
# Функция для подсчета количества строк
def count_lines(text):
    return text.count('\n') + 1
# Чтение текста из файла
with open('input.txt', 'r', encoding='utf-8') as file:
    text = file.read()
# Получение статистики
letter_count = count_letters(text)
word_count = count_words(text)
line_count = count_lines(text)
# Вывод результатов
print(f"Input file contains: {letter_count} letters")
print(f"{word_count} words")
print(f"{line_count} lines")
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/sam3.png)
## Выводы
В данном коде. 
Этот код открывает файл с именем 'input.txt', читает его содержимое, а затем с помощью трех функций подсчитывает следующую статистику:
1.count_letters(text) подсчитывает количество букв латинского алфавита в тексте.
2.count_words(text) подсчитывает количество слов в тексте.
3.count_lines(text) подсчитывает количество строк в тексте.
Затем код выводит результаты подсчета на экран, указывая количество букв, слов и строк в файле 'input.txt'.

### Функция для подсчета количества букв латинского алфавита
def count_letters(text):
    return sum(c.isalpha() and c.isascii() for c in text)
### Функция для подсчета количества слов
def count_words(text):
    return len(text.split())
### Функция для подсчета количества строк
def count_lines(text):
    return text.count('\n') + 1
### Чтение текста из файла 'input.txt'
with open('input.txt', 'r', encoding='utf-8') as file:
    text = file.read()
### Получение статистики
letter_count = count_letters(text)  # Подсчет букв латинского алфавита в тексте.
word_count = count_words(text)  # Подсчет слов в тексте.
line_count = count_lines(text)  # Подсчет строк в тексте.
### Вывод результатов
print(f"Input file contains: {letter_count} letters")  # Вывод количества букв.
print(f"{word_count} words")  # Вывод количества слов.
print(f"{line_count} lines")  # Вывод количества строк.

# Самостоятельная работа№4
### Напишите программу, которая получает на вход предложение, выводит его в терминал, заменяя все запрещенные слова звездочками * (количество звездочек равно количеству букв в слове). Запрещенные слова, разделенные символом пробела, хранятся в текстовом файле input.txt. Все слова в этом файле записаны в нижнем регистре. Программа должна заменить запрещенные слова, где бы они ни встречались, даже в середине другого слова. Замена производится независимо от регистра: если файл input.txt содержит запрещенное слово exam, то слова exam, Exam, ExaM, EXAM и exAm должны быть заменены на ****. 
· Запрещенные слова: 
hello email python the exam wor is · Предложение для проверки: 
Hello, world! Python IS the programming language of thE future. My EMAIL is.... 
Текстовое полеPYTHON is awesome!!!! 
· Ожидаемый результат: 
*****, ***ld! ****** ** *** programming language of *** future. My ***** **.... 
****** ** awesome!!!! 
```python
# Функция для замены запрещенных слов в предложении
def censor_sentence(sentence, forbidden_words):
    words = sentence.split()
    censored_words = []
    for word in words:
        # Приводим к нижнему регистру для проверки
        word_lower = word.lower()
        if word_lower in forbidden_words:
            # Заменяем слово на звездочки
            censored_word = '*' * len(word)
            censored_words.append(censored_word)
        else:
            censored_words.append(word)
    return ' '.join(censored_words)
# Замените 'input.txt' на путь к вашему файлу с запрещенными словами
forbidden_words_file = 'input.txt'
# Замените 'input_sentence.txt' на путь к вашему файлу с предложением
input_sentence_file = 'input_sentence.txt'
# Чтение запрещенных слов
forbidden_words = set()
with open(forbidden_words_file, 'r', encoding='utf-8') as file:
    for line in file:
        word = line.strip().lower()
        forbidden_words.add(word)
# Чтение предложения для проверки
with open(input_sentence_file, 'r', encoding='utf-8') as file:
    input_sentence = file.read()
# Замена запрещенных слов
censored_sentence = censor_sentence(input_sentence, forbidden_words)
# Вывод результата
print(censored_sentence)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/sam4.png)
## Выводы
В данном коде. 
Этот код выполняет следующие шаги:
1.Определяется функция censor_sentence, которая заменяет запрещенные слова в предложении на звездочки (*). Она принимает предложение и множество запрещенных слов и возвращает предложение с заменой запрещенных слов.
2.Задаются пути к файлам: 'input.txt' - файл с запрещенными словами и 'input_sentence.txt' - файл с предложением для проверки.
3.Считываются запрещенные слова из файла 'input.txt' и сохраняются в множество forbidden_words.
4.Считывается предложение из файла 'input_sentence.txt'.
5.Вызывается функция censor_sentence с предложением и множеством запрещенных слов, результат замены выводится на экран с помощью print.
6.Этот код служит для цензурирования предложений, заменяя запрещенные слова на звездочки, на основе списка запрещенных слов из файла 'input.txt'.

### Функция для замены запрещенных слов в предложении
def censor_sentence(sentence, forbidden_words):
    words = sentence.split()
    censored_words = []
    for word in words:
        ### Приводим к нижнему регистру для проверки
        word_lower = word.lower()
        if word_lower in forbidden_words:
            ### Заменяем слово на звездочки
            censored_word = '*' * len(word)
            censored_words.append(censored_word)
        else:
            censored_words.append(word)
    return ' '.join(censored_words)
### Замените 'input.txt' на путь к вашему файлу с запрещенными словами
forbidden_words_file = 'input.txt'
### Замените 'input_sentence.txt' на путь к вашему файлу с предложением
input_sentence_file = 'input_sentence.txt'
### Чтение запрещенных слов
forbidden_words = set()
with open(forbidden_words_file, 'r', encoding='utf-8') as file:
    for line in file:
        word = line.strip().lower()
        forbidden_words.add(word)
### Чтение предложения для проверки
with open(input_sentence_file, 'r', encoding='utf-8') as file:
    input_sentence = file.read()
### Замена запрещенных слов
censored_sentence = censor_sentence(input_sentence, forbidden_words)
### Вывод результата
print(censored_sentence)

# Самостоятельная работа№5
### Самостоятельно придумайте и решите задачу, которая будет взаимодействовать с текстовым файлом. 
```python
from collections import Counter
import re
# Функция для чтения файла и анализа текста
def analyze_text(file_path, num_words=10):
    with open(file_path, 'r', encoding='utf-8') as file:
        text = file.read()
        words = re.findall(r'\w+', text.lower())  # Приводим к нижнему регистру и разбиваем на слова
        word_counts = Counter(words)
        most_common_words = word_counts.most_common(num_words)  # Получаем наиболее часто встречающиеся слова

        return most_common_words
# Замените 'sample.txt' на путь к вашему текстовому файлу
file_path = 'sample.txt'
# Получаем результат анализа
most_common_words = analyze_text(file_path)
# Выводим наиболее часто встречающиеся слова
print("Наиболее часто встречающиеся слова:")
for word, count in most_common_words:
    print(f"{word}: {count} раз")
# Вы можете изменить num_words, чтобы получить больше или меньше слов в выводе
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_7/pic/sam5.png)
## Выводы
В данном коде. 
Этот код выполняет следующие шаги:
1.Импортируются модули Counter из collections и re для работы с текстом и анализа его содержимого.
2.Определена функция analyze_text, которая принимает путь к текстовому файлу и необязательный параметр num_words, по умолчанию равный 10. Функция считывает содержимое файла, разбивает его на слова (с приведением к нижнему регистру) и подсчитывает, сколько раз каждое слово встречается в тексте. Затем она возвращает список наиболее часто встречающихся слов (с указанным числом слов num_words).
3.Задается путь к текстовому файлу 'sample.txt', который нужно проанализировать.
4.Вызывается функция analyze_text с указанным файлом и полученный результат (наиболее часто встречающиеся слова) выводится на экран.
5.Примечание: Вы можете изменить значение num_words, чтобы получить больше или меньше наиболее часто встречающихся слов в выводе.

from collections import Counter
import re
### Функция для чтения файла и анализа текста
def analyze_text(file_path, num_words=10):
    with open(file_path, 'r', encoding='utf-8') as file:
        text = file.read()
        ### Приводим к нижнему регистру и разбиваем на слова
        words = re.findall(r'\w+', text.lower())  
        word_counts = Counter(words)
        ### Получаем наиболее часто встречающиеся слова
        most_common_words = word_counts.most_common(num_words)  
        return most_common_words
### Замените 'sample.txt' на путь к вашему текстовому файлу
file_path = 'sample.txt'
### Получаем результат анализа
most_common_words = analyze_text(file_path)
### Выводим наиболее часто встречающиеся слова
print("Наиболее часто встречающиеся слова:")
for word, count in most_common_words:
    print(f"{word}: {count} раз")
### Вы можете изменить num_words, чтобы получить больше или меньше слов в выводе

## Общий вывод
В этой Лабороторной работе№7 применяются "Работа с файлами (ввод, вывод)."
Работа с файлами в Python осуществляется с использованием встроенных функций open(), read(), write(), и close(). Вот примеры работы с файлами в Python:
Чтение данных из файла
Для чтения данных из файла в Python используйте open() с режимом 'r' (чтение). Затем можно использовать методы read(), readline(), или readlines() для получения данных из файла.
```python
# Открытие файла для чтения
with open('имя_файла.txt', 'r') as file:
    data = file.read()  # Чтение всего содержимого файла

print(data)
Если вы хотите читать файл построчно:
```
```python
with open('имя_файла.txt', 'r') as file:
    for line in file:
        print(line)
Запись данных в файл
Для записи данных в файл используйте open() с режимом 'w' (запись). Затем используйте метод write() для записи данных в файл.
```
```python
# Открытие файла для записи (существующее содержимое будет перезаписано)
with open('имя_файла.txt', 'w') as file:
    file.write("Это строка, которую нужно записать в файл.\n")
    file.write("Ещё одна строка для файла.\n")
Если вы хотите добавить данные к существующему файлу без перезаписи:
```
```python
# Открытие файла для добавления
with open('имя_файла.txt', 'a') as file:
    file.write("Это строка, которую нужно добавить в файл.\n")
```
После завершения операций с файлом, не забудьте закрыть файл с помощью close(). Однако лучше использовать контекстный менеджер with, как показано в примерах выше, чтобы автоматически закрыть файл после завершения работы.
Это основы работы с файлами в Python. Вы можете также обрабатывать исключения, проверять наличие файлов и множество других операций в зависимости от ваших конкретных потребностей.
