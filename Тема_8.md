# Тема №8. Введение в ООП 

Отчет по Теме № выполнил(а):

- Рублев Валерий Игоревич
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями. 
```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
my_car = Car("Toyota", "Corolla")
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/lab1.png)
## Выводы
Этот код определяет класс на Python с именем "Car" (Автомобиль), содержащий конструктор (__init__), который принимает два параметра: "make" (марка) и "model" (модель). Конструктор инициализирует переменные экземпляра self.make и self.model значениями, переданными при создании объекта класса Car. Затем создается экземпляр класса Car с маркой "Toyota" и моделью "Corolla" и присваивается переменной my_car. Теперь экземпляр my_car содержит данные "Toyota" для марки и "Corolla" для модели. Вы можете получить доступ к этим атрибутам, используя точечную нотацию, например, my_car.make и my_car.model.

### Определение класса с именем "Car" (Автомобиль)
class Car:
### Конструктор класса (__init__), который инициализирует объект класса Car
def __init__(self, make, model):
### Присваивание параметра 'make' (марка) переменной экземпляра 'self.make'
self.make = make
### Присваивание параметра 'model' (модель) переменной экземпляра 'self.model'
self.model = model
###Создание экземпляра класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")

# Лабороторная работа№2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль. 
```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
    def drive(self):
        print(f"Driving the{self.make} {self.model}")
my_car = Car("Toyota", "Corolla")
my_car.drive()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/lab2.png)
## Выводы
Этот код определяет класс "Car" с конструктором __init__, который принимает параметры "make" (марка) и "model" (модель) для инициализации переменных экземпляра self.make и self.model. Кроме того, в классе есть метод drive, который выводит сообщение о том, что автомобиль движется с указанием марки и модели.
Затем создается экземпляр класса Car с маркой "Toyota" и моделью "Corolla" и присваивается переменной my_car. После этого вызывается метод drive() на экземпляре my_car, который выводит сообщение "Водитель автомобиля Toyota Corolla".

### Определение класса "Car" (Автомобиль)
class Car:
### Конструктор класса (__init__), который инициализирует объект класса Car
def __init__(self, make, model):
### Присваивание параметра 'make' (марка) переменной экземпляра 'self.make'
self.make = make
### Присваивание параметра 'model' (модель) переменной экземпляра 'self.model'
self.model = model
### Метод класса "drive" (Двигаться)
def drive(self):
### Вывод сообщения о том, что автомобиль движется, с указанием марки и модели
print(f"Водитель автомобиля {self.make} {self.model}")
### Создание экземпляра класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
### Вызов метода "drive" на экземпляре my_car
my_car.drive()

# Лабороторная работа№3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль. 
```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
    def drive(self):
        print(f"Driving the{self.make} {self.model}")
my_car = Car("Toyota", "Corolla")
my_car.drive()
class ElectricCar(Car):
    def __init__(self, make, model, battery_capacity):
        super().__init__(make, model)
        self.battery_capacity = battery_capacity
    def charge(self):
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")
my_electric_car = ElectricCar("Tesla", "Model S", 75)
my_electric_car.drive()
my_electric_car.charge()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/lab3.png)
## Выводы
В данном коде. 
Этот код определяет два класса: "Car" и "ElectricCar". "ElectricCar" является подклассом "Car", что позволяет наследовать функциональность "Car" и добавить собственные методы и атрибуты, такие как "charge" и "battery_capacity". Создаются экземпляры обоих классов и вызываются их методы.

### Определение класса "Car" (Автомобиль)
class Car:
### Конструктор класса (__init__), который инициализирует объект класса Car
def __init__(self, make, model):
### Присваивание параметра 'make' (марка) переменной экземпляра 'self.make'
self.make = make
### Присваивание параметра 'model' (модель) переменной экземпляра 'self.model'
self.model = model
### Метод класса "drive" (Двигаться)
def drive(self):
### Вывод сообщения о том, что автомобиль движется, с указанием марки и модели
print(f"Driving the {self.make} {self.model}")
### Создание экземпляра класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
### Вызов метода "drive" на экземпляре my_car
my_car.drive()
### Определение класса "ElectricCar" (Электромобиль), который является подклассом класса "Car"
class ElectricCar(Car):
### Конструктор класса ElectricCar
def __init__(self, make, model, battery_capacity):
### Вызов конструктора класса-родителя Car с помощью super()
super().__init(make, model)
### Присваивание параметра 'battery_capacity' (емкость батареи) переменной экземпляра 'self.battery_capacity'
self.battery_capacity = battery_capacity
### Метод класса "charge" (Заряжать)
def charge(self):
### Вывод сообщения о зарядке автомобиля с указанием марки, модели и емкости батареи
print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")
### Создание экземпляра класса ElectricCar с маркой "Tesla", моделью "Model S" и емкостью батареи 75 kWh
my_electric_car = ElectricCar("Tesla", "Model S", 75)
### Вызов метода "drive" на экземпляре my_electric_car, унаследованного от класса Car
my_electric_car.drive()
### Вызов метода "charge" на экземпляре my_electric_car, специфичного для класса ElectricCar
my_electric_car.charge()

# Лабороторная работа№4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль. 
```python
class Car:
    def __init__(self, make, model):
        # Защитнный атрибут
        self._make = make 
        # Приватный атрибут
        self.__model = model  
    def drive(self):
        print(f"Driving the {self._make} {self.__model}")
my_car = Car("Toyota", "Corolla")
# Доступ к защищенному атрибуту
print(my_car._make) 
# print(my_car.__model) # Ошибка! Приватный атрибут не доступен
my_car.drive()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/lab4.png)
## Выводы
В данном коде. 
Этот код определяет класс "Car" с двумя видами атрибутов: защищенным (_make) и приватным (__model). Защищенные атрибуты могут быть доступны, но это скорее соглашение о стиле программирования, чем строгая защита. Приватные атрибуты не могут быть напрямую доступны за пределами класса.
При попытке доступа к приватному атрибуту напрямую извне класса возникает ошибка, в то время как защищенный атрибут доступен для чтения, но следует избегать прямого изменения его значений извне класса. В конце концов, вызывается метод drive, который использует оба вида атрибутов для вывода сообщения о движении автомобиля.

### Определение класса "Car" (Автомобиль)
class Car:
### Конструктор класса (__init__), который инициализирует объект класса Car
def __init__(self, make, model):
### Защищенный атрибут, доступный, но соглашение об использовании
self._make = make  
### Приватный атрибут, недоступный для прямого доступа
self.__model = model  
### Метод класса "drive" (Двигаться)
def drive(self):
### Вывод сообщения о том, что автомобиль движется, используя защищенный и приватный атрибуты
print(f"Driving the {self._make} {self.__model}")
### Создание экземпляра класса Car с маркой "Toyota" и моделью "Corolla"
my_car = Car("Toyota", "Corolla")
### Доступ к защищенному атрибуту '_make' напрямую (возможен, но не рекомендуется)
print(my_car._make)
### Попытка доступа к приватному атрибуту '__model' приведет к ошибке
### Приватный атрибут недоступен
print(my_car.__model)  
### Вызов метода "drive" на экземпляре my_car
my_car.drive()

# Лабороторная работа№5
### Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
class Shape:
    def area(self):
        pass
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14 * self.radius * self.radius
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/lab5.png)
## Выводы
Этот код определяет иерархию классов, начиная с абстрактного класса "Shape", который содержит абстрактный метод "area". Два подкласса, "Rectangle" (Прямоугольник) и "Circle" (Круг), наследуют от "Shape" и переопределяют метод "area", чтобы вычислить площадь прямоугольника и круга соответственно.
Когда создаются объекты классов "Rectangle" и "Circle" и вызываются их методы "area", они возвращают соответствующие площади для этих геометрических фигур.

### Определение абстрактного класса "Shape" (Фигура)
class Shape:
### Метод "area" (Площадь), который является абстрактным и должен быть переопределен в подклассах
def area(self):
pass
### Определение класса "Rectangle" (Прямоугольник), который является подклассом "Shape"
class Rectangle(Shape):
### Конструктор класса, который принимает ширину и высоту прямоугольника
def __init__(self, width, height):
self.width = width
self.height = height
### Переопределение метода "area" для вычисления площади прямоугольника
def area(self):
return self.width * self.height
### Определение класса "Circle" (Круг), который является подклассом "Shape"
class Circle(Shape):
### Конструктор класса, который принимает радиус круга
def __init__(self, radius):
self.radius = radius
### Переопределение метода "area" для вычисления площади круга
def area(self):
return 3.14 * self.radius * self.radius

# Самостоятельная работа№1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли. 
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def introduce(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")
# Создадим объект класса Person
person1 = Person("Иван", 30)
# Выведем информацию о созданном объекте
person1.introduce()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/sam1.png)
## Выводы
Этот код создает класс Person с двумя атрибутами (name и age) и методом introduce, который выводит информацию о человеке. Затем мы создаем объект person1 и вызываем его метод introduce, чтобы вывести информацию о человеке.

### Определение класса "Person" (Человек)
class Person:
### Конструктор класса, который инициализирует объект класса с именем и возрастом
def __init__(self, name, age):
### Присваивание параметра 'name' (имя) переменной экземпляра 'self.name'
self.name = name  
### Присваивание параметра 'age' (возраст) переменной экземпляра 'self.age'
self.age = age  
### Метод класса "introduce" (Представить себя)
def introduce(self):
### Вывод сообщения, представляющего объект класса с указанием имени и возраста
print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")
### Создание экземпляра класса Person с именем "Иван" и возрастом 30 лет
person1 = Person("Иван", 30)
### Вызов метода "introduce" на экземпляре person1
person1.introduce()

# Самостоятельная работа№2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли. 
```python
class Person:
    def __init__(self, name, age, occupation):
        self.name = name
        self.age = age
        self.occupation = occupation
        self.hobbies = []
    def introduce(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")
    
    def set_hobbies(self, hobbies):
        self.hobbies = hobbies
    
    def show_hobbies(self):
        if self.hobbies:
            print(f"Мои хобби: {', '.join(self.hobbies)}")
        else:
            print("У меня пока нет хобби.")
# Создадим объект класса Person
person1 = Person("Иван", 30, "Инженер")
# Установим хобби для объекта
person1.set_hobbies(["горные лыжи", "фотография"])
# Выведем информацию о человеке и его хобби
person1.introduce()
person1.show_hobbies()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/sam2.png)
## Выводы
В данном коде. 

### Определение класса "Person" (Человек)
class Person:
### Конструктор класса, который инициализирует объект класса с именем, возрастом и родом занятий
def __init__(self, name, age, occupation):
### Присваивание параметра 'name' (имя) переменной экземпляра 'self.name'
self.name = name  
### Присваивание параметра 'age' (возраст) переменной экземпляра 'self.age'
self.age = age 
### Присваивание параметра 'occupation' (род занятий) переменной экземпляра 'self.occupation'
self.occupation = occupation  
### Инициализация списка хобби пустым списком
self.hobbies = []  
### Метод класса "introduce" (Представить себя)
def introduce(self):
### Вывод сообщения, представляя объект класса с указанием имени и возраста
print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")
### Метод класса "set_hobbies" (Установить хобби)
def set_hobbies(self, hobbies):
### Установка списка хобби для объекта
self.hobbies = hobbies  
### Метод класса "show_hobbies" (Показать хобби)
def show_hobbies(self):
if self.hobbies:
### Если у объекта есть хобби, вывести их, разделяя запятыми
print(f"Мои хобби: {', '.join(self.hobbies)}")
else:
### В противном случае сообщить, что у объекта пока нет хобби
print("У меня пока нет хобби.")
### Создание экземпляра класса Person с именем "Иван", возрастом 30 лет и родом занятий "Инженер"
person1 = Person("Иван", 30, "Инженер")
### Установка хобби для объекта person1
person1.set_hobbies(["горные лыжи", "фотография"])
### Вывод информации о человеке (имя, возраст) и его хобби
person1.introduce()
person1.show_hobbies()

# Самостоятельная работа№3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли. 
```python
class Person:
    def __init__(self, name, age, occupation):
        self.name = name
        self.age = age
        self.occupation = occupation
        self.hobbies = []
    def introduce(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")
    def set_hobbies(self, hobbies):
        self.hobbies = hobbies
    def show_hobbies(self):
        if self.hobbies:
            print(f"Мои хобби: {', '.join(self.hobbies)}")
        else:
            print("У меня пока нет хобби.")
class Employee(Person):
    def __init__(self, name, age, occupation, salary):
        super().__init__(name, age, occupation)
        self.salary = salary
    def introduce(self):
        print(f"Привет, меня зовут {self.name}, я работаю как {self.occupation}, и моя зарплата составляет {self.salary}.")
# Создадим объект класса Employee
employee1 = Employee("Мария", 25, "Программист", 50000)
# Выведем информацию о работнике
employee1.introduce()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/sam3.png)
## Выводы
Этот код определяет два класса: "Person" и "Employee". "Employee" является подклассом "Person". Класс "Person" содержит общую информацию о человеке, включая имя, возраст и хобби. Класс "Employee" наследует от "Person" и добавляет информацию о зарплате и переопределяет метод "introduce" для представления себя как сотрудника с указанием имени, рода занятий и зарплаты. Создается экземпляр класса "Employee" и выводится информация о работнике.

### Определение класса "Person" (Человек)
class Person:
### Конструктор класса, который инициализирует объект класса с именем, возрастом, родом занятий и пустым списком хобби
def __init__(self, name, age, occupation):
### Присваивание параметра 'name' (имя) переменной экземпляра 'self.name'
self.name = name 
### Присваивание параметра 'age' (возраст) переменной экземпляра 'self.age'
self.age = age  
### Присваивание параметра 'occupation' (род занятий) переменной экземпляра 'self.occupation'
self.occupation = occupation  
### Инициализация списка хобби пустым списком
self.hobbies = []  
### Метод класса "introduce" (Представить себя)
def introduce(self):
### Вывод сообщения, представляя объект класса с указанием имени и возраста
print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")
### Метод класса "set_hobbies" (Установить хобби)
def set_hobbies(self, hobbies):
### Установка списка хобби для объекта
self.hobbies = hobbies  
### Метод класса "show_hobbies" (Показать хобби)
def show_hobbies(self):
if self.hobbies:
### Если у объекта есть хобби, вывести их, разделяя запятыми
print(f"Мои хобби: {', '.join(self.hobbies)}")
else:
### В противном случае сообщить, что у объекта пока нет хобби
print("У меня пока нет хобби.")
### Определение класса "Employee" (Сотрудник), который является подклассом "Person"
class Employee(Person):
### Конструктор класса "Employee", который добавляет параметр "salary" (зарплата) и вызывает конструктор родительского класса
def __init__(self, name, age, occupation, salary):
### Вызов конструктора родительского класса для инициализации общих параметров
super().__init__(name, age, occupation)  
### Присваивание параметра 'salary' переменной экземпляра 'self.salary'
self.salary = salary  
### Переопределение метода "introduce" для сотрудника, включая информацию о зарплате
def introduce(self):
### Вывод сообщения, представляя себя как сотрудника с указанием имени, рода занятий и зарплаты
print(f"Привет, меня зовут {self.name}, я работаю как {self.occupation}, и моя зарплата составляет {self.salary}.")
### Создание экземпляра класса Employee с именем "Мария", возрастом 25 лет, родом занятий "Программист" и зарплатой 50000
employee1 = Employee("Мария", 25, "Программист", 50000)
### Вывод информации о работнике (имя, род занятий и зарплата)
employee1.introduce()

# Самостоятельная работа№4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли. 
```python
class Person:
    def __init__(self, name, age, occupation):
        self.name = name
        self.age = age
        self._occupation = occupation  # Используем префикс _ для инкапсуляции
    def introduce(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет. Я работаю как {self._occupation}.")
# Создадим объект класса Person
person1 = Person("Иван", 30, "Инженер")
# Выведем информацию о человеке
person1.introduce()
# Попытка доступа к "скрытому" атрибуту _occupation
print(f"Моя профессия: {person1._occupation}")
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/sam4.png)
## Выводы
Код создает объект класса Person с именем "Иван", возрастом 30 и профессией "Инженер". Затем метод introduce используется для вывода информации о человеке, включая его имя, возраст и профессию. Наконец, показывается попытка доступа к "скрытому" атрибуту _occupation, которая успешно выводит профессию "Инженер".

### Создаем класс Person
class Person:
def __init__(self, name, age, occupation):
### Инициализируем атрибут name
self.name = name 
### Инициализируем атрибут age
self.age = age    
### Инициализируем "скрытый" атрибут _occupation с использованием префикса _
self._occupation = occupation  
def introduce(self):
### Метод introduce выводит информацию о человеке, используя атрибуты name, age и _occupation
print(f"Привет, меня зовут {self.name} и мне {self.age} лет. Я работаю как {self._occupation}.")
### Создаем объект класса Person с именем "Иван", возрастом 30 и профессией "Инженер"
person1 = Person("Иван", 30, "Инженер")
### Вызываем метод introduce для объекта person1, который выводит информацию о нем
person1.introduce()
### Попытка доступа к "скрытому" атрибуту _occupation
print(f"Моя профессия: {person1._occupation}")

# Самостоятельная работа№5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли. 
```python
class Dog:
    def make_sound(self):
        return "Гав-гав!"
class Cat:
    def make_sound(self):
        return "Мяу!"
def print_sound(animal):
    print(animal.make_sound())
# Создадим объекты
dog = Dog()
cat = Cat()
# Вызовем метод make_sound для собаки и кошки
print_sound(dog)
print_sound(cat)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_8/pic/sam5.png)
## Выводы
В данном коде. 
Код описывает классы Dog и Cat, которые представляют собаку и кошку соответственно. У каждого из этих классов есть метод make_sound, который возвращает звук, издаваемый данным животным.
Далее в коде определена функция print_sound, которая принимает объект животного в качестве аргумента и вызывает метод make_sound для этого объекта, затем выводит результат на экран с помощью функции print.
Далее создаются два объекта: dog (собака) и cat (кошка), и для каждого из них вызывается функция print_sound, чтобы вывести соответствующие звуки, которые издают собака и кошка.

### Определение класса Dog
class Dog:
### Метод make_sound для собаки, возвращающий строку "Гав-гав!"
def make_sound(self):
return "Гав-гав!"
### Определение класса Cat
class Cat:
### Метод make_sound для кошки, возвращающий строку "Мяу!"
def make_sound(self):
return "Мяу!"
### Функция print_sound принимает объект animal и вызывает его метод make_sound, затем выводит результат
def print_sound(animal):
print(animal.make_sound())
### Создание объектов dog (собака) и cat (кошка)
dog = Dog()
cat = Cat()
### Вызов метода make_sound для собаки и кошки с использованием функции print_sound
print_sound(dog)  # Выводит "Гав-гав!"
print_sound(cat)  # Выводит "Мяу!"

## Общий вывод
В этой Лабороторной работе№8 применяются "Введение в ООП"
Объектно-ориентированное программирование (ООП) - это парадигма программирования, которая базируется на концепциях объектов и классов. В ООП данные и функции обрабатываются в виде объектов, которые являются экземплярами классов.

Основные понятия ООП:
1.Класс: Класс - это шаблон или чертёж для создания объектов. Он определяет атрибуты (переменные) и методы (функции), которые будут доступны объектам данного класса.
2.Объект: Объект - это конкретный экземпляр класса. Он содержит данные, хранящиеся в атрибутах, и может вызывать методы класса для выполнения определенных операций.
3.Инкапсуляция: Инкапсуляция означает сокрытие данных и методов класса от внешнего доступа. Это позволяет управлять доступом к данным и обеспечивает безопасность.
4.Наследование: Наследование позволяет создавать новые классы на основе существующих. Новый класс (подкласс) наследует атрибуты и методы родительского класса, что способствует повторному использованию кода.
5.Полиморфизм: Полиморфизм позволяет объектам разных классов использовать общий интерфейс для выполнения различных операций. Это упрощает работу с разными объектами, не зная их конкретного типа.

Пример на Python:
```python
class Животное:
    def __init__(self, имя):
        self.имя = имя
    def голос(self):
        pass
class Собака(Животное):
    def голос(self):
        return "Гав-гав!"
class Кошка(Животное):
    def голос(self):
        return "Мяу!"
собака = Собака("Барон")
кошка = Кошка("Мурка")
print(собака.голос())  # Выводит "Гав-гав!"
print(кошка.голос())   # Выводит "Мяу!"
```
Это простой пример использования классов, наследования и полиморфизма в объектно-ориентированном программировании.
