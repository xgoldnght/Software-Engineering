# Тема №9. Концепции и принципы ООП

Отчет по Теме № выполнил(а):

- Рублев Валерий Игоревич
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | + | 
| Задание 7 | + | 
| Задание 8 | + | 
| Задание 9 | + | 
| Задание 10 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.
```python

```
### Результат
![Меню]()
## Выводы
В данном коде. 


# Лабороторная работа№2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
```python

```
### Результат
![Меню]()
## Выводы
В данном коде. 


# Лабороторная работа№3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. 
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка. 
```python

```
### Результат
![Меню]()
## Выводы
В данном коде. 


# Лабороторная работа№4
### Вам	прекрасно	известно,	что	кошки	и	собаки	являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга. 
```python

```
### Результат
![Меню]()
## Выводы
В данном коде. 

# Лабороторная работа№5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной декоратор @staticmethod, поскольку нам параметры-ссылки вроде self. 
```python

```
### Результат
![Меню]()
## Выводы
В данном коде. 


# Самостоятельная работа№1
### Задание Садовник и помидоры. 
Классовая структура: 
Текстовое полеЕсть Помидор со следующими характеристиками: 
· Индекс 
· Стадия созревания (стадии: отсутствует, цветение, зеленый, красный) 
Помидор может: 
· Расти (переходить на следующую стадию созревания) · Предоставлять информацию о своей зрелости 
Есть Куст с помидорами, который: 
· Содержит список томатов, которые на нем растут 
А также может: 
· Расти вместе с томатами 
· Предоставлять информацию о зрелости всех томатов · Предоставлять урожай 
И также есть Садовник, который имеет: 
· Имя 
· Растение, за которым он ухаживает 
Он может: 
· Ухаживать за растением · Собирать с него урожай 
Задание: 
Класс Tomato: 
1) Создайте класс Tomato 
2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора 
3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state 
(принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства 
4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания 
5) Создайте метод is_ripe(), который будет проверять, что томат созрел 
Текстовое полеКласс TomatoBush: 
1) Создайте класс TomatoBush 
2) Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes 
3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания 
4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми. 
5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая 
Класс Gardener: 
1) Создайте класс Gardener 
2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства 
3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым 
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение 
5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству 
Тесты: 
1) Вызовите справку по садоводству 
2) Создайте объекты классов TomatoBush и Gardener 
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами 
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними 
5) Соберите урожай 
Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов. 
```python
class Tomato:
    # Статическое свойство с стадиями созревания помидора
    states = {"отсутствует": 0, "цветение": 1, "зеленый": 2, "красный": 3}
    def __init__(self, index):
        # Динамические свойства
        self._index = index
        self._state = Tomato.states["отсутствует"]
    def grow(self):
        if self._state < Tomato.states["красный"]:
            self._state += 1
    def is_ripe(self):
        return self._state == Tomato.states["красный"]
class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)
    def give_away_all(self):
        self.tomatoes = []
class Gardener:
    def __init__(self, name, plant):
        # Динамические свойства
        self.name = name
        self._plant = plant
    def work(self):
        self._plant.grow_all()
    def harvest(self):
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
        else:
            print("Пока не все помидоры созрели. Продолжайте ухаживать за ними.")
    @staticmethod
    def knowledge_base():
        print("Справка по садоводству: ...")
# Тесты
if __name__ == "__main__":
    Gardener.knowledge_base()
    tomato_bush = TomatoBush(5)
    gardener = Gardener("John", tomato_bush)
    # Рост томатов
    gardener.work()  
    # Собрать урожай (не все созрели)
    gardener.harvest()  
    # Продолжение ухода
    gardener.work()  
    # Продолжение ухода
    gardener.work()  
    # Продолжение ухода
    gardener.work()  
    # Собрать урожай (все созрели)
    gardener.harvest()  
```
### Результат
![Меню]()
## Выводы
Данный код реализует систему для управления ростом и уходом за помидорами в саду с использованием классов Tomato, TomatoBush и Gardener. Вот что каждая часть кода делает:
Tomato - это класс, представляющий отдельный помидор. Он имеет статическое свойство states, которое определяет стадии созревания помидора. У каждого помидора есть два динамических свойства: _index (уникальный идентификатор) и _state (текущая стадия созревания). Класс также имеет методы grow(), который переводит помидор на следующую стадию созревания, и is_ripe(), который проверяет, созрел ли помидор.
TomatoBush - это класс, представляющий куст с помидорами. Он инициализируется с заданным количеством помидоров. Каждый куст хранит список объектов Tomato. У класса есть методы: grow_all(), который переводит все помидоры на следующий этап созревания, all_are_ripe(), который проверяет, все ли помидоры стали спелыми, и give_away_all(), который очищает список помидоров после сбора урожая.
Gardener - это класс, представляющий садовника. Он инициализируется с именем и объектом TomatoBush. У класса есть методы: work(), который заставляет садовника работать и ухаживать за растением, что позволяет помидорам становиться более зрелыми, и harvest(), который проверяет, все ли помидоры созрели. Если все помидоры созрели, садовник собирает урожай, иначе выводится предупреждение.
В коде также присутствует статический метод knowledge_base(), который предоставляет справку по садоводству, но в данном коде справка не определена.
Тесты в конце кода выполняют следующие действия:
1.Выводят справку по садоводству.
2.Создают куст с пятью помидорами и садовника по имени "John".
3.Затем садовник ухаживает за кустом с помидорами несколько раз.
4.Происходит попытка собрать урожай, и если все помидоры созрели, они собираются.
5.Результатом выполнения кода и тестов будет управление ростом и уходом за помидорами, а также сбор спелого урожая в саду.



## Общий вывод
В этой Лабороторной работе№ применяются "Концепции и принципы ООП"
Объектно-ориентированное программирование (ООП) - это методология программирования, которая базируется на концепциях и принципах, направленных на организацию кода вокруг объектов. Вот основные концепции и принципы ООП:

1.Объекты: Основной элемент ООП - это объект. Объект представляет собой экземпляр класса и может содержать данные (поля) и методы (функции), которые оперируют этими данными.
2.Классы: Класс - это шаблон или описание, на основе которого создаются объекты. Класс определяет структуру данных (поля) и операции над этими данными (методы), которые объекты класса могут выполнять.
3.Инкапсуляция: Инкапсуляция означает ограничение доступа к данным и методам объекта. Это достигается с помощью модификаторов доступа (public, private, protected), что позволяет скрыть детали реализации и предоставить интерфейс для работы с объектом.
4.Наследование: Наследование позволяет создавать новый класс на основе существующего, наследуя его поля и методы. Это способствует повторному использованию кода и созданию иерархии классов.
5.Полиморфизм: Полиморфизм означает способность объектов разных классов выполнять одну и ту же операцию (метод) в специфическом для своего класса контексте. Это может быть реализовано через перегрузку методов или использование интерфейсов.
6.Абстракция: Абстракция позволяет скрыть детали реализации и представить только необходимую информацию. Это упрощает взаимодействие с объектами и позволяет сосредоточиться на существенных аспектах.
7.Поле (атрибут): Поле - это переменная, хранящая данные объекта. Они определяют состояние объекта.
8.Метод: Метод - это функция, которая выполняет операции над данными объекта. Методы определяют поведение объекта.
9.Интерфейс: Интерфейс - это абстрактный класс, который определяет методы, которые должны быть реализованы в подклассах. Интерфейсы обычно используются для определения контракта, который класс должен соблюдать. В разных языках программирования существуют различные способы определения интерфейсов и их реализации. Если у вас есть конкретные вопросы или нужна дополнительная информация о создании и использовании интерфейсов в программировании, пожалуйста, уточните свой запрос.
