# Тема №9. Концепции и принципы ООП

Отчет по Теме №9 выполнил(а):

- Рублев Валерий Игоревич
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + 
| Задание 3 | + 
| Задание 4 | + 
| Задание 5 | + 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.
```python
class Ivan:
    __slots__ = ['name']
    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"
person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)
person2.surname = 'Петров'
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_9/pic/lab1.png)
## Выводы
В данном коде создается класс Ivan с одним атрибутом name. Если при создании экземпляра класса Ivan передается имя 'Иван', то атрибут name получает значение "Да, я Иван", в противном случае значение "Я не {name}, а Иван". Класс также использует __slots__, чтобы ограничить список допустимых атрибутов экземпляра класса, и в данном случае, попытка присвоить значение атрибуту surname вызовет ошибку.

### Создаем класс Ivan
class Ivan:
### Используем __slots__ для определения допустимых атрибутов экземпляра класса
__slots__ = ['name']
### Конструктор класса, который принимает имя в качестве аргумента
def __init__(self, name):
### Проверяем, если имя равно 'Иван', то присваиваем атрибуту name строку "Да, я Иван"
if name == 'Иван':
self.name = f"Да, я {name}"
### В противном случае присваиваем атрибуту name строку "Я не {name}, а Иван"
else:
self.name = f"Я не {name}, а Иван"
### Создаем экземпляры класса Ivan
person1 = Ivan('Алексей')
person2 = Ivan('Иван')
### Выводим значения атрибута name для обоих экземпляров
print(person1.name)  # Выводит: "Я не Алексей, а Иван"
print(person2.name)  # Выводит: "Да, я Иван"
### Попытка присвоить значение атрибуту surname для person2 вызовет ошибку, так как surname не определен в __slots__
### Вызовет ошибку: AttributeError: 'Ivan' object has no attribute 'surname'
person2.surname = 'Петров'  

# Лабороторная работа№2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None
    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print('Обычное морожженое')
icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_9/pic/lab2.png)
## Выводы
В данном коде создается класс Icecream с конструктором, который принимает аргумент ingredient. Если ingredient является строкой, то он присваивается атрибуту ingredient класса. Метод composition выводит состав мороженого на основе значения атрибута ingredient. Если ingredient не является строкой или не задан, то выводится "Обычное мороженое".

### Создаем класс Icecream
class Icecream:
### Конструктор класса принимает аргумент ingredient, по умолчанию равный None
def __init__(self, ingredient=None):
### Проверяем, если ingredient является строкой, то присваиваем его атрибуту ingredient
if isinstance(ingredient, str):
self.ingredient = ingredient
### В противном случае атрибут ingredient остается None
else:
self.ingredient = None
### Метод composition печатает состав мороженого
def composition(self):
if self.ingredient:
print(f"Мороженое с {self.ingredient}")
else:
print('Обычное мороженое')
### Создаем экземпляр класса Icecream без аргумента
icecream = Icecream()
### Выводит: "Обычное мороженое"
icecream.composition() 
### Создаем экземпляр класса Icecream с аргументом 'шоколадом'
icecream = Icecream('шоколадом')
### Выводит: "Мороженое с шоколадом"
icecream.composition()  
### Создаем экземпляр класса Icecream с аргументом 5 (не строкой)
icecream = Icecream(5)
### Выводит: "Обычное мороженое"
icecream.composition()  

# Лабороторная работа№3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. 
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка. 
```python
class MyClass:
    def __init__(self, value):
        self._value = value
    def set_value(self, value):
        self._value = value
    def get_value(self):
        return self._value
    def del_value(self):
        del self._value
    value = property(get_value, set_value, del_value, 'Свойство value')
obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_9/pic/lab3.png)
## Выводы
Этот код определяет класс MyClass с атрибутом _value, который можно устанавливать, получать и удалять с использованием методов. Кроме того, создается свойство value, которое обеспечивает доступ к атрибуту _value с помощью методов get_value, set_value и del_value.

### Создание класса MyClass
class MyClass:
### Конструктор класса, инициализирует атрибут _value
def __init__(self, value):
self._value = value
### Метод для установки значения атрибута _value
def set_value(self, value):
self._value = value
### Метод для получения значения атрибута _value
def get_value(self):
return self._value
### Метод для удаления атрибута _value
def del_value(self):
del self._value
### Создание свойства value с методами get_value, set_value и del_value
value = property(get_value, set_value, del_value, 'Свойство value')
### Создание объекта obj класса MyClass с начальным значением 42
obj = MyClass(42)
### Вывод значения атрибута _value с использованием метода get_value
print(obj.get_value())  # Вывод: 42
### Изменение значения атрибута _value с использованием метода set_value
obj.set_value(45)
### Вывод обновленного значения атрибута _value
print(obj.get_value())  # Вывод: 45
### Изменение значения атрибута _value снова
obj.set_value(100)
### Вывод обновленного значения атрибута _value
### Вывод: 100
print(obj.get_value())  
### Удаление атрибута _value с использованием метода del_value
obj.del_value()
### Попытка доступа к удаленному атрибуту _value
### вызовет ошибку AttributeError, так как атрибут больше не существует
### Вызовет ошибку AttributeError
print(obj.get_value()) 

# Лабороторная работа№4
### Вам	прекрасно	известно,	что	кошки	и	собаки	являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга. 
```python
class Mammal:
    className = 'Mammal'
class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'
class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'
dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_9/pic/lab4.png)
## Выводы
Этот код представляет собой простой пример наследования классов в Python.

### Определение базового класса Mammal (Млекопитающее)
class Mammal:
### Создание атрибута className и установка его значения 'Mammal'
className = 'Mammal'  
### Определение класса Dog (Собака), который наследует от Mammal
class Dog(Mammal):
### Создание атрибута species и установка его значения 'canine'
species = 'canine'   
### Создание атрибута sounds и установка его значения 'wow'
sounds = 'wow'      
### Определение класса Cat (Кошка), который также наследует от Mammal
class Cat(Mammal):
### Создание атрибута species и установка его значения 'feline'
species = 'feline'  
### Создание атрибута sounds и установка его значения 'meow'
sounds = 'meow'    
### Создание объекта dog как экземпляра класса Dog
dog = Dog()
### Вывод строки, в которой отображается className и sounds для объекта dog
print(f"Dog is {dog.className}, but they say {dog.sounds}")
### Создание объекта cat как экземпляра класса Cat
cat = Cat()
### Вывод строки, в которой отображается className и sounds для объекта cat
print(f"Cat is {cat.className}, but they say {cat.sounds}")

# Лабороторная работа№5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной декоратор @staticmethod, поскольку нам параметры-ссылки вроде self. 
```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")
class English:
    @staticmethod
    def greeting():
        print("Hello")
def greet(language):
    language.greeting()
ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_9/pic/lab5.png)
## Выводы
В данном коде создаются два класса, Russian и English, каждый из которых содержит статический метод greeting. Функция greet принимает объект language и вызывает его статический метод greeting. В результате вызова greet(ivan) выводится "Привет", а вызов greet(john) выводит "Hello". Это демонстрирует, как можно использовать статические методы в классах для выполнения действий, не связанных с конкретными экземплярами объектов.

### Определение класса Russian (Русский)
class Russian:
@staticmethod
def greeting():
print("Привет")
### Определение класса English (Английский)
class English:
@staticmethod
def greeting():
print("Hello")
### Определение функции greet, которая принимает объект language и вызывает его статический метод greeting
def greet(language):
language.greeting()
### Создание объекта ivan как экземпляра класса Russian
ivan = Russian()
### Вызов функции greet, передавая ей объект ivan (класс Russian)
greet(ivan)
### Создание объекта john как экземпляра класса English
john = English()
### Вызов функции greet, передавая ей объект john (класс English)
greet(john)

# Самостоятельная работа№1
### Задание Садовник и помидоры. 
Классовая структура: 
Текстовое полеЕсть Помидор со следующими характеристиками: 
· Индекс 
· Стадия созревания (стадии: отсутствует, цветение, зеленый, красный) 
Помидор может: 
· Расти (переходить на следующую стадию созревания) · Предоставлять информацию о своей зрелости 
Есть Куст с помидорами, который: 
· Содержит список томатов, которые на нем растут 
А также может: 
· Расти вместе с томатами 
· Предоставлять информацию о зрелости всех томатов · Предоставлять урожай 
И также есть Садовник, который имеет: 
· Имя 
· Растение, за которым он ухаживает 
Он может: 
· Ухаживать за растением · Собирать с него урожай 
Задание: 
Класс Tomato: 
1) Создайте класс Tomato 
2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора 
3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state 
(принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства 
4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания 
5) Создайте метод is_ripe(), который будет проверять, что томат созрел 
Текстовое полеКласс TomatoBush: 
1) Создайте класс TomatoBush 
2) Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes 
3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания 
4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми. 
5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая 
Класс Gardener: 
1) Создайте класс Gardener 
2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства 
3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым 
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение 
5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству 
Тесты: 
1) Вызовите справку по садоводству 
2) Создайте объекты классов TomatoBush и Gardener 
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами 
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними 
5) Соберите урожай 
Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов. 
```python
class Tomato:
    # Статическое свойство с стадиями созревания помидора
    states = {"отсутствует": 0, "цветение": 1, "зеленый": 2, "красный": 3}
    def __init__(self, index):
        # Динамические свойства
        self._index = index
        self._state = Tomato.states["отсутствует"]
    def grow(self):
        if self._state < Tomato.states["красный"]:
            self._state += 1
    def is_ripe(self):
        return self._state == Tomato.states["красный"]
class TomatoBush:
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)
    def give_away_all(self):
        self.tomatoes = []
class Gardener:
    def __init__(self, name, plant):
        # Динамические свойства
        self.name = name
        self._plant = plant
    def work(self):
        self._plant.grow_all()
    def harvest(self):
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
        else:
            print("Пока не все помидоры созрели. Продолжайте ухаживать за ними.")
    @staticmethod
    def knowledge_base():
        print("Справка по садоводству: ...")
# Тесты
if __name__ == "__main__":
    Gardener.knowledge_base()
    tomato_bush = TomatoBush(5)
    gardener = Gardener("John", tomato_bush)
    # Рост томатов
    gardener.work()  
    # Собрать урожай (не все созрели)
    gardener.harvest()  
    # Продолжение ухода
    gardener.work()  
    # Продолжение ухода
    gardener.work()  
    # Продолжение ухода
    gardener.work()  
    # Собрать урожай (все созрели)
    gardener.harvest()  
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_9/pic/sam1.png)
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_9/pic/sam1.1.png)
## Выводы
Данный код реализует систему для управления ростом и уходом за помидорами в саду с использованием классов Tomato, TomatoBush и Gardener. Вот что каждая часть кода делает:
Tomato - это класс, представляющий отдельный помидор. Он имеет статическое свойство states, которое определяет стадии созревания помидора. У каждого помидора есть два динамических свойства: _index (уникальный идентификатор) и _state (текущая стадия созревания). Класс также имеет методы grow(), который переводит помидор на следующую стадию созревания, и is_ripe(), который проверяет, созрел ли помидор.
TomatoBush - это класс, представляющий куст с помидорами. Он инициализируется с заданным количеством помидоров. Каждый куст хранит список объектов Tomato. У класса есть методы: grow_all(), который переводит все помидоры на следующий этап созревания, all_are_ripe(), который проверяет, все ли помидоры стали спелыми, и give_away_all(), который очищает список помидоров после сбора урожая.
Gardener - это класс, представляющий садовника. Он инициализируется с именем и объектом TomatoBush. У класса есть методы: work(), который заставляет садовника работать и ухаживать за растением, что позволяет помидорам становиться более зрелыми, и harvest(), который проверяет, все ли помидоры созрели. Если все помидоры созрели, садовник собирает урожай, иначе выводится предупреждение.
В коде также присутствует статический метод knowledge_base(), который предоставляет справку по садоводству, но в данном коде справка не определена.
Тесты в конце кода выполняют следующие действия:
1.Выводят справку по садоводству.
2.Создают куст с пятью помидорами и садовника по имени "John".
3.Затем садовник ухаживает за кустом с помидорами несколько раз.
4.Происходит попытка собрать урожай, и если все помидоры созрели, они собираются.
5.Результатом выполнения кода и тестов будет управление ростом и уходом за помидорами, а также сбор спелого урожая в саду.

## Общий вывод
В этой Лабороторной работе№ применяются "Концепции и принципы ООП"
Объектно-ориентированное программирование (ООП) - это методология программирования, которая базируется на концепциях и принципах, направленных на организацию кода вокруг объектов. Вот основные концепции и принципы ООП:

1.Объекты: Основной элемент ООП - это объект. Объект представляет собой экземпляр класса и может содержать данные (поля) и методы (функции), которые оперируют этими данными.
2.Классы: Класс - это шаблон или описание, на основе которого создаются объекты. Класс определяет структуру данных (поля) и операции над этими данными (методы), которые объекты класса могут выполнять.
3.Инкапсуляция: Инкапсуляция означает ограничение доступа к данным и методам объекта. Это достигается с помощью модификаторов доступа (public, private, protected), что позволяет скрыть детали реализации и предоставить интерфейс для работы с объектом.
4.Наследование: Наследование позволяет создавать новый класс на основе существующего, наследуя его поля и методы. Это способствует повторному использованию кода и созданию иерархии классов.
5.Полиморфизм: Полиморфизм означает способность объектов разных классов выполнять одну и ту же операцию (метод) в специфическом для своего класса контексте. Это может быть реализовано через перегрузку методов или использование интерфейсов.
6.Абстракция: Абстракция позволяет скрыть детали реализации и представить только необходимую информацию. Это упрощает взаимодействие с объектами и позволяет сосредоточиться на существенных аспектах.
7.Поле (атрибут): Поле - это переменная, хранящая данные объекта. Они определяют состояние объекта.
8.Метод: Метод - это функция, которая выполняет операции над данными объекта. Методы определяют поведение объекта.
9.Интерфейс: Интерфейс - это абстрактный класс, который определяет методы, которые должны быть реализованы в подклассах. Интерфейсы обычно используются для определения контракта, который класс должен соблюдать. В разных языках программирования существуют различные способы определения интерфейсов и их реализации. Если у вас есть конкретные вопросы или нужна дополнительная информация о создании и использовании интерфейсов в программировании, пожалуйста, уточните свой запрос.
