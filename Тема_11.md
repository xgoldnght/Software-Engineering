# Тема №11. Итераторы и генераторы

Отчет по Теме № выполнил(а):

- Рублев Валерий Игоревич
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + |
| Задание 4 | + | 
| Задание 5 | + | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev() 
```python
numbers = [0, 1, 2, 3, 4, 5]
for item in numbers:
    print(item)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_11/pic/lab1.png)
## Выводы
Этот код делает следующее: 
1. Создает список чисел от 0 до 5 и присваивает его переменной с именем "numbers". 
2. Запускает цикл for, который проходит по каждому элементу в списке "numbers". 
3. Для каждого из этих элементов (которые временно получают имя "item") выполнится код в блоке цикла. В данном случае, этот код просто печатает значение каждого элемента на экран. 

### Определение списка numbers
numbers = [0, 1, 2, 3, 4, 5]
### Итерация по элементам списка и вывод каждого элемента
for item in numbers:
    print(item) 

# Лабороторная работа№2
### Класс итератор с гибкой настройкой и удобными применением
```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1
    def __iter__(self):
        return self
    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count
if __name__ == '__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_11/pic/lab2.png)
## Выводы
Код выводит числа от 5 до 0 включительно, шагая вниз с каждой итерацией цикла.

### Определяем класс с именем CountDown
class CountDown:
### Специальная функция __init__ выполняется при создании каждого нового объекта этого класса
### Число, переданное при создании объекта, сохраняется в атрибуте count, увеличенном на 1 
def __init__(self, start):
self.count = start + 1
### Специальная функция __iter__ сообщает Python, что этот объект можно использовать в цикле
### Возвращает самого себя
def __iter__(self):
return self
### Специальная функция __next__ определяет, что произойдет при каждой итерации цикла
def __next__(self):
### При каждом вызове __next__, count уменьшается на 1
self.count -= 1
### Если count стал меньше нуля, то бросается исключение StopIteration, сообщающее Python о завершении итераций
if self.count < 0:
raise StopIteration
### Если count не меньше нуля, то возвращает текущее значение count
return self.count
### Это защита от выполнения кода при импорте этого файла.
### Если этот файл запускается как главный, то код выполняется.
### Если этот файл импортирован в другой файл, то код не выполняется.
if __name__ == '__main__':
### Создает объект CountDown, инициализируя его числом 5
counter = CountDown(5)
### Для каждого i в объекте counter выводит i (эти i - это результаты вызова метода __next__)
for i in counter:
print(i)

# Лабороторная работа№3
### Генератор списка 
```python
a = [i ** 2 for i in range(1, 5)]
print('a - ', a)
for i in a:
    print(i)
print('iter(a) - ', iter(a))
for i in a:
    print(i)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_11/pic/lab3.png)
## Выводы
В данном коде. 
Этот код создает список квадратов первых четырех натуральных чисел, затем печатает этот список и каждый его элемент отдельно. Затем он создает итератор для этого списка и снова печатает элементы списка. В результате каждый элемент списка печатается дважды. "iter(a)" в принте выводит адрес в памяти объекта итератора, который не особо информативен для пользователя.

### Создание списка 'a' с использованием спискового включения (list comprehension). Для каждого числа (i) в диапазоне от 1 (включительно) до 5 (не включительно),
### добавляется его квадрат в список 'a'. Получается список [1, 4, 9, 16].
a = [i ** 2 for i in range(1, 5)]
### Выводим на экран содержимое списка 'a'
print('a - ', a)
### Проходимся циклом по всем элементам списка 'a' и выводим каждый элемент на экран
for i in a:
print(i)
### Создание и печать итератора для списка 'a'. Он возвращает объект итератора, который можно использовать для прохода по элементам списка.
print('iter(a) - ', iter(a))
### Аналогично проходимся циклом по всем элементан списка 'a' и выводим каждый элемент на экран
for i in a:
print(i)

# Лабороторная работа№4
### Выражения генераторы 
```python
b = (i ** 2 for i in range(1, 5))
print(b)
print('first')
for i in b:
    print(i)
print('second')
for i in b:
    print(i)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_11/pic/lab4.png)
## Выводы
Сначала давайте разберёмся, что делает каждая строка отдельно:
1. `b = (i ** 2 for i in range(1, 5))`: эта строка создает генератор `b`, который порождает квадраты чисел от 1 до 4 (включительно).
2. `print(b)`: эта строка выводит представление генератора `b`. Это не выведет элементы в генераторе. Вместо этого, вы увидите что-то вроде `<generator object <genexpr> at 0x....>`, которое говорит о том, что b является генератором.
3. `print('first')`: эта строка просто выводит строку `'first'`.
4. `for i in b: print(i)`: здесь проходит цикл по всем элементам генератора `b` и выводит каждый элемент на экран. Поскольку `b` содержит квадраты чисел от 1 до 4, вы увидите числа 1, 4, 9 и 16. Важно отметить, что после обхода элементов в генераторе они "исчезают" - они не сохраняются и не могут быть перебраны снова.
5. `print('second')`: эта строка просто выводит строку 'second'.
6. `for i in b: print(i)`: эта строка пытается повторно пройти циклом по элементам генератора `b`. Однако, поскольку эти элементы уже были полностью израсходованы в первом прогоне цикла, этот цикл не сделает и не выведет ничего.
Итак, этот код демонстрирует два важных свойства генераторов в Python:
1. Генераторы не хранят все свои значения в памяти, а генерируют их на лету.
2. Когда элементы генератора были израсходованы (например, они были перебраны в цикле), они "исчезают" и не могут быть использованы снова. 

### Создание генератора 'b'. Генераторы подобны спискам, но они не хранятся в памяти целиком, а генерируют каждый следующий элемент "на лету".
### Здесь создается генератор, который пройдет через числа от 1 до 4 (включительно), возведенные в квадрат.
b = (i ** 2 for i in range(1, 5))
### Выводим на экран содержимое генератора 'b'. Это не содержит никакой полезной информации для пользователя, 
### так как генераторы не могут быть "распечатаны" по аналогии со списками.
print(b)
print('first')
### Проходимся циклом по всем элементам генератора 'b' и выводим каждый элемент на экран.
### Проход по генератору автоматически "израсходует" его, элементы нельзя перечислить второй раз.
for i in b:
print(i)
print('second')
### Пытаемся пройти циклом по всем элементам генератора 'b' во второй раз и выводить каждый элемент на экран.
### Ничего не выводится, поскольку генератор уже был "израсходован" при первом проходе.
for i in b:
print(i)

# Лабороторная работа№5
### Такой же счетчик, как и в первом задании, только это генератор и использует yield 
```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1
if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_11/pic/lab5.png)
## Выводы
Так что при запуске этого кода он напечатает целые числа от 5 до 0 включительно, каждое в отдельной строке. Это происходит, потому что программа создает генератор counter с помощью функциии countdown, начинающей с 5 и заканчивающей 0, а затем проходит через каждое значение в этом генераторе и печатает его.

### Определите функцию двухсотрудничества с именем countdown
def countdown(count):
### функция принимает аргумент count, который представляет собой счетчик обратного отсчета
### while цикл выполняется до тех пор, пока count больше или равен нулю
while count >= 0:
### yield превращает функцию в генератор и приостанавливает функцию,
### возвращая текущее значение count до следующего вызова 
yield count 
### счетчик уменьшается на 1 после каждой итерации
count -= 1
### проверьте, выполняется ли это скрипт напрямую
### (а не импортирован ли он из другого модуля)
if __name__ == '__main__':
### запустите обратный отсчет с 5
counter = countdown(5)
### обходите все значения в генераторе и распечатайте каждое значение
for i in counter:
print(i)

# Самостоятельная работа№1
### Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному). Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200. 
```python
def fib(n):
    a, b = 1, 1
    for _ in range(n):
        yield a
        a, b = b, a + b
fib_numbers = list(fib(200))
print(fib_numbers[-1])
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_11/pic/sam1.png)
## Выводы
Данный код сначала создает генератор последовательности Фибоначчи, генерирующий первые 200 чисел этой последовательности. Затем он преобразует этот генератор в список fib_numbers. Последней строкой кода печатается последнее число в этом списке (если точнее, двухсотое число в последовательности Фибоначчи), используя отрицательный индекс -1, который ссылается на последний элемент списка в Python.

### Определение функции для генерации последовательности Фибоначчи
def fib(n):
### Инициализация первых двух чисел последовательности Фибоначчи    
a, b = 1, 1
### Цикл, который генерирует 'n' чисел последовательности Фибоначчи
for _ in range(n):
### 'yield' используется для создания генератора, который возвращает текущее число Фибоначчи
yield a
### обновляем значения 'a' и 'b' для следующей итерации
a, b = b, a + b
### создаем список из первых 200 чисел Фибоначчи   
fib_numbers = list(fib(200))
### выводим последнее число из этого списка
print(fib_numbers[-1])

# Самостоятельная работа№2
### К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла 
```python
def fib(n):
    a, b = 1, 1
    count = 0
    with open("fib.txt", "w") as file:
        while count < n:
            file.write(str(a) + "\n")
            yield a
            a, b = b, a+b
            count += 1
# Генерируем 200 чисел Фибоначчи
fibonacci_iter = fib(200)
# Выводим результат в консоль
for num in fibonacci_iter:
    print(num)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_11/pic/sam2.png)
## Выводы
Этот код создает генератор, который генерирует первые 200 чисел последовательности Фибоначчи. Каждое сгенерированное число записывается в файл "fib.txt" (который будет находиться в той же директории, что и скрипт) в виде одного числа на строку в формате текста. Также все числа выводятся в консоль.
Логически, этот код разбивает генерацию чисел Фибоначчи на индивидуальные шаги, после каждого из которых он записывает текущее число в файл, прежде чем переходить к следующему. Это делает его эффективным для работы с большими последовательностями, т.к. он не требует хранения всех чисел последовательности в памяти одновременно.

### Определение функции для генерации последовательности Фибоначчи
def fib(n):
### Инициализация первых двух чисел последовательности Фибоначчи и счетчика    
a, b = 1, 1
count = 0
### Открытие файла "fib.txt" для записи
with open("fib.txt", "w") as file:
### Цикл будет выполняться, пока значение счетчика меньше заданного 'n'
while count < n:
### Запись текущего числа Фибоначчи в файл, преобразованного в строку, с добавлением перевода строки
file.write(str(a) + "\n")
### 'yield' используется для возвращения текущего числа Фибоначчи,
### после каждого этого вызова выполнение функции приостанавливается
yield a
### Обновляем значения 'a' и 'b' для следующей итерации
a, b = b, a + b
### Увеличиваем значение счетчика на 1
count += 1
### Генерируем 200 чисел последовательности Фибоначчи
fibonacci_iter = fib(200)
### Выводим полученные числа Фибоначчи в консоль
for num in fibonacci_iter:
print(num)

## Общий вывод
В этой Лабороторной работе№ применяются "Итераторы и генераторы"
В Python, итераторы и генераторы связаны с концепцией "итерации", то есть процесса обхода элементов коллекции (такой как список) по одному. 

1. **Итераторы**: 

    Итератор - это объект, который реализует методы `__iter__()` и `__next__()`. `__iter__` возвращает итератор и `__next__` возвращает следующий элемент из итератора. Если больше нет элементов, `__next__` генерирует исключение `StopIteration`. 

    Здесь пример простого итератора:

    ```python
    class Counter:
        def __init__(self, low, high):
            self.current = low
            self.high = high

        def __iter__(self):
            return self

        def __next__(self):
            if self.current > self.high:
                raise StopIteration
            else:
                self.current += 1
                return self.current - 1
    ```

    Этот итератор будет возвращать числа в заданном диапазоне. Вы можете использовать его так:

    ```python
    for x in Counter(3, 8):
        print(x)
    ```

2. **Генераторы**:

    Генератор является специальным типом итератора, но его определение более простое. Генераторы используют слово `yield` вместо `return` в функции. 

    Вот пример функции-генератора:

    ```python
    def counter(low, high):
        current = low
        while current <= high:
            yield current
            current += 1
    ```

    Используется она так же, как в примере с классом итератором:

    ```python
    for x in counter(3, 8):
        print(x)
    ```

    Генераторы эффективны по памяти, так как они не продюссируют все значения сразу, а генерируют их на лету. Это особенно полезно при работе с большими последовательностями данных.

    Функция-генератор это своего рода итератор, но она автоматически останавливает и восстанавливает свое состояние при каждом вызове `yield`, так что на практике они гораздо удобнее для использования.
  
Важно понимать, что итераторы и генераторы нельзя повторно использовать – как только они израсходованы, вам нужно будет снова вызвать функцию `__iter__()` (для итераторов) или пересоздать генератор (для генераторов), чтобы снова пройти коллекцию.
