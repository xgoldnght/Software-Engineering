# Тема №11. Итераторы и генераторы

Отчет по Теме № выполнил(а):

- Рублев Валерий Игоревич
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + |
| Задание 4 | + | 
| Задание 5 | + | 

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev() 
```python
numbers = [0, 1, 2, 3, 4, 5]
for item in numbers:
    print(item)
```
### Результат
![Меню]()
## Выводы
Этот код делает следующее: 
1. Создает список чисел от 0 до 5 и присваивает его переменной с именем "numbers". 
2. Запускает цикл for, который проходит по каждому элементу в списке "numbers". 
3. Для каждого из этих элементов (которые временно получают имя "item") выполнится код в блоке цикла. В данном случае, этот код просто печатает значение каждого элемента на экран. 

### Определение списка numbers
numbers = [0, 1, 2, 3, 4, 5]
### Итерация по элементам списка и вывод каждого элемента
for item in numbers:
    print(item) 

# Лабороторная работа№2
### Класс итератор с гибкой настройкой и удобными применением
```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1
    def __iter__(self):
        return self
    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count
if __name__ == '__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)
```
### Результат
![Меню]()
## Выводы
Код выводит числа от 5 до 0 включительно, шагая вниз с каждой итерацией цикла.

### Определяем класс с именем CountDown
class CountDown:
### Специальная функция __init__ выполняется при создании каждого нового объекта этого класса
### Число, переданное при создании объекта, сохраняется в атрибуте count, увеличенном на 1 
def __init__(self, start):
self.count = start + 1
### Специальная функция __iter__ сообщает Python, что этот объект можно использовать в цикле
### Возвращает самого себя
def __iter__(self):
return self
### Специальная функция __next__ определяет, что произойдет при каждой итерации цикла
def __next__(self):
### При каждом вызове __next__, count уменьшается на 1
self.count -= 1
### Если count стал меньше нуля, то бросается исключение StopIteration, сообщающее Python о завершении итераций
if self.count < 0:
raise StopIteration
### Если count не меньше нуля, то возвращает текущее значение count
return self.count
### Это защита от выполнения кода при импорте этого файла.
### Если этот файл запускается как главный, то код выполняется.
### Если этот файл импортирован в другой файл, то код не выполняется.
if __name__ == '__main__':
### Создает объект CountDown, инициализируя его числом 5
counter = CountDown(5)
### Для каждого i в объекте counter выводит i (эти i - это результаты вызова метода __next__)
for i in counter:
print(i)

# Лабороторная работа№3
### Генератор списка 
```python
a = [i ** 2 for i in range(1, 5)]
print('a - ', a)
for i in a:
    print(i)
print('iter(a) - ', iter(a))
for i in a:
    print(i)
```
### Результат
![Меню]()
## Выводы
В данном коде. 
Этот код создает список квадратов первых четырех натуральных чисел, затем печатает этот список и каждый его элемент отдельно. Затем он создает итератор для этого списка и снова печатает элементы списка. В результате каждый элемент списка печатается дважды. "iter(a)" в принте выводит адрес в памяти объекта итератора, который не особо информативен для пользователя.

### Создание списка 'a' с использованием спискового включения (list comprehension). Для каждого числа (i) в диапазоне от 1 (включительно) до 5 (не включительно),
### добавляется его квадрат в список 'a'. Получается список [1, 4, 9, 16].
a = [i ** 2 for i in range(1, 5)]
### Выводим на экран содержимое списка 'a'
print('a - ', a)
### Проходимся циклом по всем элементам списка 'a' и выводим каждый элемент на экран
for i in a:
print(i)
### Создание и печать итератора для списка 'a'. Он возвращает объект итератора, который можно использовать для прохода по элементам списка.
print('iter(a) - ', iter(a))
### Аналогично проходимся циклом по всем элементан списка 'a' и выводим каждый элемент на экран
for i in a:
print(i)

# Лабороторная работа№4
### Выражения генераторы 
```python
b = (i ** 2 for i in range(1, 5))
print(b)
print('first')
for i in b:
    print(i)
print('second')
for i in b:
    print(i)
```
### Результат
![Меню]()
## Выводы
Сначала давайте разберёмся, что делает каждая строка отдельно:
1. `b = (i ** 2 for i in range(1, 5))`: эта строка создает генератор `b`, который порождает квадраты чисел от 1 до 4 (включительно).
2. `print(b)`: эта строка выводит представление генератора `b`. Это не выведет элементы в генераторе. Вместо этого, вы увидите что-то вроде `<generator object <genexpr> at 0x....>`, которое говорит о том, что b является генератором.
3. `print('first')`: эта строка просто выводит строку `'first'`.
4. `for i in b: print(i)`: здесь проходит цикл по всем элементам генератора `b` и выводит каждый элемент на экран. Поскольку `b` содержит квадраты чисел от 1 до 4, вы увидите числа 1, 4, 9 и 16. Важно отметить, что после обхода элементов в генераторе они "исчезают" - они не сохраняются и не могут быть перебраны снова.
5. `print('second')`: эта строка просто выводит строку 'second'.
6. `for i in b: print(i)`: эта строка пытается повторно пройти циклом по элементам генератора `b`. Однако, поскольку эти элементы уже были полностью израсходованы в первом прогоне цикла, этот цикл не сделает и не выведет ничего.
Итак, этот код демонстрирует два важных свойства генераторов в Python:
1. Генераторы не хранят все свои значения в памяти, а генерируют их на лету.
2. Когда элементы генератора были израсходованы (например, они были перебраны в цикле), они "исчезают" и не могут быть использованы снова. 

### Создание генератора 'b'. Генераторы подобны спискам, но они не хранятся в памяти целиком, а генерируют каждый следующий элемент "на лету".
### Здесь создается генератор, который пройдет через числа от 1 до 4 (включительно), возведенные в квадрат.
b = (i ** 2 for i in range(1, 5))
### Выводим на экран содержимое генератора 'b'. Это не содержит никакой полезной информации для пользователя, 
### так как генераторы не могут быть "распечатаны" по аналогии со списками.
print(b)
print('first')
### Проходимся циклом по всем элементам генератора 'b' и выводим каждый элемент на экран.
### Проход по генератору автоматически "израсходует" его, элементы нельзя перечислить второй раз.
for i in b:
print(i)
print('second')
### Пытаемся пройти циклом по всем элементам генератора 'b' во второй раз и выводить каждый элемент на экран.
### Ничего не выводится, поскольку генератор уже был "израсходован" при первом проходе.
for i in b:
print(i)

# Лабороторная работа№5
### Такой же счетчик, как и в первом задании, только это генератор и использует yield 
```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1
if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)
```
### Результат
![Меню]()
## Выводы
Так что при запуске этого кода он напечатает целые числа от 5 до 0 включительно, каждое в отдельной строке. Это происходит, потому что программа создает генератор counter с помощью функциии countdown, начинающей с 5 и заканчивающей 0, а затем проходит через каждое значение в этом генераторе и печатает его.

### Определите функцию двухсотрудничества с именем countdown
def countdown(count):
### функция принимает аргумент count, который представляет собой счетчик обратного отсчета
### while цикл выполняется до тех пор, пока count больше или равен нулю
while count >= 0:
### yield превращает функцию в генератор и приостанавливает функцию,
### возвращая текущее значение count до следующего вызова 
yield count 
### счетчик уменьшается на 1 после каждой итерации
count -= 1
### проверьте, выполняется ли это скрипт напрямую
### (а не импортирован ли он из другого модуля)
if __name__ == '__main__':
### запустите обратный отсчет с 5
counter = countdown(5)
### обходите все значения в генераторе и распечатайте каждое значение
for i in counter:
print(i)

# Самостоятельная работа№1
### 
 
```python

```
### Результат
![Меню]()
## Выводы
В данном коде.  


# Самостоятельная работа№2
### 

```python

```
### Результат
![Меню]()
## Выводы
В данном коде. 



## Общий вывод
В этой Лабороторной работе№ применяются "Итераторы и генераторы"

