# Тема №10. Декораторы и исключения

Отчет по Теме №10 выполнил(а):

- Рублев Валерий Игоревич
  
- ОЗИВТ-22-1-у
  
| Задание | Лаб_Раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:

- к.э.н, доцент Панов М.А

# Лабороторная работа№1
### Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи. 
P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания. 
```python
from functools import lru_cache
@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
if __name__ == '__main__':
    print(fibonacci(100))
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/lab1.png)
## Выводы
Этот код использует мемоизацию с декоратором lru_cache для хранения ранее вычисленных чисел Фибоначчи и улучшения производительности. Функция fibonacci вычисляет число Фибоначчи для заданного значения n. Блок if name == 'main': гарантирует, что утверждение print будет выполнено только при запуске скрипта напрямую, а не при импорте как модуля.

from functools import lru_cache
### Импортируем функцию lru_cache из модуля functools. lru_cache - это декоратор, который добавляет кэширование в вашу функцию, тем самым приостанавливая повторные вычисления, если функция вызывается с теми же аргументами.
@lru_cache(None)
### Применяем lru_cache к функции fibonacci как декоратор. 'None' означает, что не задано ограничение на количество кэшируемых значений.
def fibonacci(n):
### Определяем функцию fibonacci, которая принимает один параметр 'n'. Функция вычисляет n-ное число Фибоначчи.
if n == 0: и return 0
### Проверяем, равно ли значение 'n' нулю. Если да, возвращает значение 0 (определяется как первое число в последовательности Фибоначчи).
elif n == 1: и return 1
### Проверяем, равно ли значение 'n' единице. Если да, то возвращаем значение 1 (определяется как второе число в последовательности Фибоначчи).
return fibonacci(n - 1) + fibonacci(n - 2)
### Если 'n' больше 1, применяем рекурсивное вычисление чисел Фибоначчи. Это сумма двух предыдущих чисел в последовательности Фибоначчи.
if __name__ == '__main__':
### Условие для проверки, является ли текущий файл главным исполняемым модулем.
print(fibonacci(100))
### Вызываем нашу функцию с аргументом 100 для вычисления 100-го числа в последовательности Фибоначчи и выводим результат на экран.

# Лабороторная работа№2
### Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130. 
Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента. 
```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]
        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)
    return output_func
@check
def personal_info(name, age):
    print(f"Name: {name} Age {age}")
if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/lab2.png)
## Выводы
### Код использует декоратор для проверки корректности возраста перед выводом информации о пользователе. Позвольте мне прокомментировать каждую строку:
def check(input_func):
### Определяем декоратор с именем 'check'. Он принимает функцию в качестве аргумента (в данном случае 'input_func').
def output_func(*args):
### Внутри декоратора определяем функцию 'output_func', которая принимает произвольное количество аргументов (запакованы в кортеж 'args').
name, age = args[0], args[1]
### Распаковываем кортеж 'args' в переменные 'name' и 'age'. 'name' будет первым элементом кортежа, а 'age' – вторым.
if age < 0 or age > 130: и age = 'Недопустимый возраст'
### Проверяем допустимый ли возраст. Возраст ниже 0 и выше 130 считается недопустимым. Если это так, меняем 'age' на строку 'Недопустимый возраст'.
input_func(name, age)
### Вызываем 'input_func' с параметрами 'name' и 'age'. Это будет проверенная и возможно измененная версия входных параметров.
return output_func
### Возвращаем 'output_func', который будет заменять оригинальную функцию 'personal_info', если она будет декорирована 'check'.
@check
### Применяем декоратор 'check' к функции 'personal_info'.
def personal_info(name, age): и print(f"Name: {name} Age {age}")
### Определяем функцию 'personal_info', которая просто выводит имя и возраст. Эта функция будет выполняться только после функции 'output_func' благодаря декоратору 'check'.
if __name__ == '__main__':
### Условие для проверки, является ли текущий файл главным исполняемым модулем.
personal_info('Владимир', 38),
personal_info('Александр', -5),
personal_info('Петр', 138, 15, 48, 2)
### Вызов функции 'personal_info' с различными аргументами.
Обратите внимание, что последняя строка передает слишком много параметров для функции 'personal_info',
но благодаря звездочке в 'output_func(*args)', это не вызывает ошибку. Вместо этого дополнительные возраста игнорируются.

# Лабороторная работа№3
### Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string. Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт. Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.
```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')
if __name__ == '__main__':
    data ([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/lab3.png)
## Выводы
Код обрабатывает данные из списка, умножая численные значения на 15 и делит на 10. Если элемент не является числом, код обрабатывает исключения, выводит исключение и идет дальше. В конце работы код выводит строку "Вся информация обработана".
def data(*args):
### Определение функции data с принимаемыми аргументами, которые запакованы в кортеж под названием args
try:
### Начало блока попытки, где код пытается выполнить вложенные операции.
for i in range(len(*args)):
### Цикл for, который проходит по длине аргументов функции. Здесь мы используем развертывание аргументов *args, так как args является кортежем, и его длина является количеством переданных в функцию аргументов.
Внутренний try:
### Начало вложенного блока попытки, где код пытается выполнить специфические операции с каждым элементом списка.
result = (args[0][i] * 15) // 10 и print(result)
### Код пытается умножить каждый элемент списка на 15, затем делить на 10. Полученный результат печатается на экран. Если элемент списка не является числом, операции приведут к ошибке.
except Exception as ex: и print(ex)
### Если код внутри try: приводит к возникновению исключения, оно будет перехвачено здесь и напечатано.
Внешний except Exception as ex: и print(ex)
### Если код внутри внешнего try: приводит к возникновению исключения (например, неправильное количество аргументов для функции len), оно будет перехвачено здесь и напечатано.
finally: и print('Вся информация обработана')
### Блок finally: выполняется в любом случае, независимо от того, возникли исключения в try: или нет. Здесь он просто печатает сообщение, что вся информация была обработана.
if __name__ == '__main__':
### Это условие проверяет, является ли текущий файл основным исполняемым модулем в программе.
data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
### Вызывается функция data с одним элементом - списком из чисел и строк. В результате числа будут обработаны, а для строк будут показаны исключения и вывод финального сообщения.

# Лабороторная работа№4
### Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация”.
```python
class NegativeValueException(Exception):
    pass
def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')
if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/lab4.png)
## Выводы
Этот код определяет функцию проверки длины имени (check_name). Если длина имени превышает 10 символов, генерируется исключение NegativeValueException с сообщением "Длина более 10 символов". Если длина имени не превышает 10 символов, на экран выводится сообщение "Успешная регистрация".
В главной части кода задается переменная name, значение которой сейчас - строка '12345678910', состоящая из 11 символов. После этого вызывается функция check_name с этим именем.
Поскольку длина заданного имени превышает 10 символов, будет сгенерировано исключение NegativeValueException с сообщением "Длина более 10 символов", и программа завершится с ошибкой. Для обработки этого исключения можно использовать блок try/except в главной части программы.

class NegativeValueException(Exception):
### Создание нового класса исключения, который наследуется от встроенного класса Exception. Это кастомное исключение, предназначенное для конкретной ситуации в нашей программе.
pass
### pass - это встроенная команда в Python, которая ничего не делает. Она используется, когда синтаксис требует наличия какого-то кода, но никакой код выполнять не нужно. В данном случае pass используется после объявления нового класса исключения, так как мы не добавляем в него никакой дополнительной функциональности.
def check_name(name):
### Определение функции check_name, которая принимает один аргумент - name.
if len(name) > 10:
### Условное выражение, которое проверяет, больше ли длина переданного имени 10 символов.
raise NegativeValueException('Длина более 10 символов')
### В случае, если длина имени больше 10 символов, генерируется исключение NegativeValueException с сообщением 'Длина более 10 символов'.
else:
### Если условие не выполняется (то есть длина имени не превышает 10 символов), выполняется код после else:.
print('Успешная регистрация')
### Пишет в консоль 'Успешная регистрация', что означает, что длина имени меньше или равна 10 символам.
if __name__ == '__main__':
### Это условие проверяет, является ли текущий файл основным исполняемым модулем в программе.
name = '12345678910'
### Присваивание строкового значения '12345678910' переменной name.
check_name(name)
### Вызов функции check_name с аргументом name. Так как длина name больше 10 символов, будет сгенерировано исключение 'Длина более 10 символов'.

# Лабороторная работа№5
### После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: __init__() (вызывается при создании класса декоратора в программе) и __call__() (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль. 
```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func
    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')
@SiteChecker
def site():
    print('Усердная работа сайта')
if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/lab5.png)
## Выводы 
Этот код Python определяет класс SiteChecker и функцию site(), которую затем использует в качестве декоратора. Ниже приведено его подробное описание:
class SiteChecker:
1.Класс, который используется как декоратор. Декораторы в Python - это способ модифицировать поведение функции или класса. Именно так функциями обрабатывается реальная работа.
def __init__(self, func):
2.Метод инициализации конструктора класса SiteChecker. Он принимает функцию в качестве аргумента и сохраняет ее внутри экземпляра класса.
print('> Класс SiteChecker метод init успешный запуск')
3.При создании экземпляра класса будет выводиться это сообщение.
self.func = func
4.Этот код сохраняет переданную функцию внутри экземпляра класса.
def __call__(self):
5.Это особый метод, который делает экземпляр класса вызываемым (т.е. позволяет его использовать как функцию).
print('> Проверка перед запуском')
6.При вызове экземпляра будет выводиться это сообщение.
self.func()
7.Это вызов сохраненной функции.
print('> Проверка безопасного выключения')
8.После выполнения функции будет выводиться это сообщение.
@SiteChecker
9.Это применение декоратора SiteChecker к функции ниже. Функция, описанная ниже, будет обернута экземпляром класса SiteChecker.
def site():
10.Это функция, которую мы оборачиваем. Все, что она делает, – выводит строку "Усердная работа сайта".
if __name__ == '__main__':
11.Это шаблон, который обеспечивает выполнение кода только в том случае, если этот файл запускается напрямую, а не импортируется в качестве модуля.
Также в этом блоке кода вызывается функция site(), окруженная декоратором SiteChecker, и выводится строка "Сайт выключен" после этого.

class SiteChecker:
def __init__(self, func):
### Объявление и инициализация класса SiteChecker. Метод __init__ является специальным методом,
### который вызывается при создании экземпляра класса.
print('> Класс SiteChecker метод __init__ успешный запуск')
### сохранение функции, которую мы "обернем" с помощью SiteChecker
self.func = func  
def __call__(self):
### Метод __call__ позволяет экземпляр класса вести себя как функцию.
### В этом примере метод __call__ будет вызываться когда мы "вызываем" экземпляр класса как функцию.
### Выводим название функции которую собираемся запустить
print('> Проверка перед запуском', self.func.__name__)  
### Запускаем сохраненную функцию
self.func()  
print('> Проверка безопасного выключения')  # Проверка после выполнения функции
### Это декоратор. Он "оборачивает" функцию site() экземпляром класса SiteChecker
@SiteChecker  
def site():
### Это декорируемая функция. Она выполняет основную работу.
print('Усердная работа сайта')
if __name__ == '__main__':
### Это точка входа в программу. Сюда программа приходит при запуске.
print('>> Сайт запущен')
### Вызов функции site(), обернутой в декоратор SiteChecker
site()  
### Объявление о том что программа закончила работу
print('>> Сайт выключен')  

# Самостоятельная работа№1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. 
Подсказка: необходимо использовать модуль time Декоратор необходимо использовать для этой функции: 
def fibonacci(): fib1 = fib2= 1 
for i inrange(2, 200): fib1,fib2= fib2,fib1 + fib2 print(fib2,end=' ') 
if__name__ == '__main__': fibonacci() 
Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы. 
Также на этом примере можете посмотреть, что решение задач через рекурсию не всегда является хорошей идеей. Поскольку решение Фибоначчи для 100 с использованием рекурсии и без динамического программирования решается более десяти секунд, а решение точно такой же задачи, но через цикл for еще и для 200, занимает меньше 1 секунды. 
```python
import time
def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции {func.__name__}: {execution_time} секунд")
        return result
    return wrapper
@measure_time
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')
if __name__ == '__main__':
    fibonacci()
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/sam1.png)
## Выводы
Код определяет декоратор measure_time, который замеряет и выводит время выполнения задекорированной функции. Декоратор применяется к функции fibonacci, которая вычисляет первые 200 чисел ряда Фибоначчи.

### Импорт модуля time, который предоставляет функции для работы со временем
import time
### Определение функции-декоратора measure_time, которая принимает другую функцию (func) в качестве аргумента
def measure_time(func):
### Внутри функции-декоратора определяется новая функция wrapper, которая может принимать любое количество позиционных и именованных аргументов
def wrapper(*args, **kwargs):
### Засекается начальное время выполнения функции
start_time = time.time()
### Вызывается исходная функция с переданными аргументами и результат сохраняется
result = func(*args, **kwargs)
### Засекается конечное время выполнения функции
end_time = time.time()
### Вычисляется и выводится на печать время выполнения функции
execution_time = end_time - start_time
print(f"Время выполнения функции {func.__name__}: {execution_time} секунд")
### Возвращается результат выполнения исходной функции
return result
### Возвращается функция wrapper вместо исходной функции, на которую теперь указывает имя исходной функции
return wrapper
### К функции fibonacci применяется декоратор measure_time
@measure_time
### Определение функции fibonacci, которая выводит на печать первые 200 чисел ряда Фибоначчи
def fibonacci():
fib1 = fib2 = 1
for i in range(2, 200):
fib1, fib2 = fib2, fib1 + fib2
print(fib2, end=' ')
### Чтобы при импорте модуля код не запускался автоматически, он помещается в блок условия __name__ == '__main__'
if __name__ == '__main__':
### Вызывается функция fibonacci, к которой применяется декоратор measure_time
fibonacci()

# Самостоятельная работа№2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла. 
```python
file_name = "empty_file.txt"
try:
    with open(file_name, 'r') as file:
        content = file.read()
        if len(content) == 0:
            raise Exception("файл пустой")
        else:
            print(content)
except FileNotFoundError:
    print(f"Файл {file_name} не найден")
except Exception as e:
    print(e)
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/sam2.png)
## Выводы
Код пытается открыть файл и считать его содержимое. Если файл не может быть найден, генерируется исключение FileNotFoundError, которое обрабатывается и приводит к сообщению о том, что файл не найден. Если файл пустой (то есть его содержимое имеет длину 0), то генерируется общее исключение, которое также обрабатывается и печатает сообщение, объект исключения хранит то, что файл пустой. 

### Строка, содержащая имя файла, который мы хотим открыть
file_name = "empty_file.txt"
### Блок try...except используется для обработки исключений
try:
### Открываем файл с именем, содержащимся в переменной file_name, в режиме чтения ('r')
with open(file_name, 'r') as file:
### Читаем содержимое файла и сохраняем его в переменную content
content = file.read()
### Если длина содержимого файла равна нулю (то есть файл пуст), вызываем исключение с сообщением "файл пустой"
if len(content) == 0:
raise Exception("файл пустой")
### Если файл не пуст, печатаем его содержимое
else:
print(content)
### Обрабатываем исключение, если файл не найден                   
except FileNotFoundError:
### Печатаем сообщение о том, что файл не найден
print(f"Файл {file_name} не найден")
### Обрабатываем все остальные исключения
except Exception as e:
### Печатаем сообщение об исключении
print(e)

# Самостоятельная работа№3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль 
```python

```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/sam3.png)
## Выводы
Данный код выполняет функцию, которая запрашивает у пользователя ввод числа, прибавляет к этому числу два и выводит результат. Это делается дважды, поскольку функция `add_two_to_input()` вызывается два раза. 
Подробнее о том, что делает каждая часть кода:
1. Функция `add_two_to_input()` определяется. Эта функция не принимает входных параметров.
2. Внутри функции происходит следующее:
- С помощью функции `input()` запрашивается ввод пользователя. Эта функция выводит на экран строку "Введите число: " и ждет, пока пользователь что-то введет.
- Этот ввод пользователя сохраняется в переменной `user_input`. Программа предполагает, что пользователь введет число.
- Функция `float(user_input)` пытается преобразовать этот ввод в число с плавающей точкой (то есть, десятичное число). Если пользователь ввел что-то, что нельзя преобразовать в число, то завершается выполнение блока кода внутри `try` и начинается выполнение блока `except ValueError`. В этом блоке выводится сообщение "Неподходящий тип данных. Ожидалось число." и функция завершает свое выполнение.
- Если преобразование в число прошло успешно, то к этому числу прибавляется 2, и результат сохраняется в переменной `result`.
- Затем этот результат выводится на экран в форматированном виде: после строки "Результат сложения: " выводится полученное число.
3. После определения функции она вызывается дважды. То есть, все описанные выше действия производятся дважды: дважды запрашивается ввод пользователя, дважды это число увеличивается на 2, и дважды результат выводится на экран.

### Определение функции с именем add_two_to_input
def add_two_to_input():
### Обработка исключений с помощью try/except
try:
### Запрос ввода числа от пользователя
user_input = input("Введите число: ")
### Преобразование введенной пользователем строки в число с плавающей точкой
number = float(user_input)
### Выполнение операции добавления к введенному пользователем числу числа 2
result = 2 + number
### Вывод результата операции
print(f"Результат сложения: {result}")
### Обработка исключения, вызванного вводом пользователем нечислового значения
except ValueError:
print("Неподходящий тип данных. Ожидалось число.")
### Вызов функции add_two_to_input для тестирования
add_two_to_input()
### Повторный вызов функции add_two_to_input для тестирования
add_two_to_input()

# Самостоятельная работа№4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода. 
```python
class Logger:
    def __init__(self, func):
        self.func = func
    def __call__(self, *args, **kwargs):
        # Выводим информацию о вызове функции и переданных аргументах
        print(f'Вызов функции {self.func.__name__}')
        print(f'Аргументы: args={args}, kwargs={kwargs}')
        # Вызываем декорируемую функцию
        return self.func(*args, **kwargs)
@Logger
def add(x, y):
    return x + y
@Logger
def subtract(x, y):
    return x - y
# Вызываем декорированные функции
result1 = add(3, 5)
result2 = subtract(10, 7)
print(f'Результат сложения: {result1}')
print(f'Результат вычитания: {result2}')
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/sam4.png)
## Выводы
В данном примере мы создали класс-декоратор Logger, который выводит информацию о вызове функции и переданных аргументах. Затем мы декорировали функции add() и subtract() с помощью этого декоратора.
При вызове декорированных функций, в консоли была выведена информация о вызове функций и переданных аргументах. Кроме того, были выведены результаты выполнения функций.
class Logger:
def __init__(self, func):
self.func = func
def __call__(self, *args, **kwargs):
### Выводим информацию о вызове функции и переданных аргументах
print(f'Вызов функции {self.func.__name__}')
print(f'Аргументы: args={args}, kwargs={kwargs}')
### Вызываем декорируемую функцию
return self.func(*args, **kwargs)
@Logger
def add(x, y):
return x + y
@Logger
def subtract(x, y):
return x - y
### Вызываем декорированные функции
result1 = add(3, 5)
result2 = subtract(10, 7)
print(f'Результат сложения: {result1}')
print(f'Результат вычитания: {result2}')

# Самостоятельная работа№5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода. 
```python
class CustomException(Exception):
    pass
try:
    num1 = int(input("Введите первое число: "))
    num2 = int(input("Введите второе число: "))
    if num2 == 0:
        raise CustomException("Деление на ноль недопустимо!")
    result = num1 / num2
    print("Результат деления:", result)
except ValueError:
    print("Ошибка: некорректный ввод числа!")
except CustomException as ex:
    print("Ошибка:", str(ex))
def check_age(age):
    if age < 0:
        raise CustomException("Возраст не может быть отрицательным числом!")
    if age > 100:
        raise CustomException("Возраст не может быть больше 100!")
    print("Возраст:", age)
try:
    age = int(input("Введите ваш возраст: "))
    check_age(age)
except ValueError:
    print("Ошибка: некорректный ввод возраста!")
except CustomException as ex:
    print("Ошибка:", str(ex))
```
### Результат
![Меню](https://github.com/xgoldnght/Software-Engineering/blob/Тема_10/pic/sam5.png)
## Выводы
В этом коде на языке программирования Python реализовано несколько сценариев обработки исключений посредством создания пользовательского исключения `CustomException` и использования конструкции `try/except`.
1. Класс `CustomException` наследуется от базового класса `Exception`. Он представляет собой пользовательское исключение и может быть использован для генерации исключений с пользовательскими сообщениями об ошибках.
2. В начальном сценарии кода создается блок `try/except`, где пользователю предлагается ввести два числа. Если второе число равно нулю, то поднимается исключение `CustomException` со специфическим сообщением о недопустимости деления на ноль. В случае, если ввод пользователя нельзя преобразовать в целое число (`int`), `ValueError` будет перехвачен и выведено сообщение о некорректности ввода.
3. Затем определена функция `check_age` для проверки валидности введенного возраста. Если возраст меньше 0 или больше 100, поднимается исключение `CustomException` с соответствующим сообщением об ошибке.
4. В следующем блоке `try/except` пользователю предлагается ввести свой возраст, который затем проверяется функцией `check_age`. Если ввод пользователя снова нельзя преобразовать в целое число или если возраст не удовлетворяет критериям, которые определены в `check_age`, то соответствующее исключение будет перехвачено и выведено соответствующее сообщение об ошибке.

### Определение пользовательского исключения CustomException
class CustomException(Exception):
pass
### Попытка выполнить код
try:
num1 = int(input("Введите первое число: "))
num2 = int(input("Введите второе число: "))
### Проверка на деление на ноль
if num2 == 0:
raise CustomException("Деление на ноль недопустимо!")
result = num1 / num2
print("Результат деления:", result)
### Обработка исключения ValueError (некорректный ввод числа)
except ValueError:
print("Ошибка: некорректный ввод числа!")
### Обработка пользовательского исключения CustomException
except CustomException as ex:
print("Ошибка:", str(ex))
### Определение функции check_age
def check_age(age):
### Проверка возраста на отрицательность
if age < 0:
raise CustomException("Возраст не может быть отрицательным числом!")
### Проверка возраста на больше 100
if age > 100:
raise CustomException("Возраст не может быть больше 100!")
print("Возраст:", age)
### Попытка выполнить код
try:
age = int(input("Введите ваш возраст: "))
check_age(age)
### Обработка исключения ValueError (некорректный ввод возраста)
except ValueError:
print("Ошибка: некорректный ввод возраста!")
### Обработка пользовательского исключения CustomException
except CustomException as ex:
print("Ошибка:", str(ex))


## Общий вывод
В этой Лабороторной работе№ применяются "Декораторы и исключения"
Декораторы - это специальные функции в Python, которые позволяют модифицировать поведение других функций, добавляя к ним дополнительную функциональность без изменения их существующего кода. Декораторы используются для различных задач, таких как логирование, проверка аргументов, кэширование результатов и многое другое.
Исключения - это события, которые возникают во время выполнения программы и перебрасывают управление к соответствующему обработчику исключений. Использование исключений позволяет упростить обработку ошибок и создать более надежные программы. В Python есть несколько встроенных исключений, таких как ValueError, TypeError, FileNotFoundError и т. д.
Исключения и декораторы можно использовать совместно для обработки и перехвата исключений в декорированных функциях.
Например, можно создать декоратор, который будет перехватывать исключения, возникающие в декорируемой функции, и выполнять определенные действия при их возникновении. Ниже приведен пример такого декоратора:
```python
Copy code
def handle_exceptions(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print("Exception occurred:", str(e))
    return wrapper
```
Этот декоратор будет перехватывать все исключения, возникающие в декорируемой функции, и выводить сообщение об исключении.
Пример использования декоратора с исключениями:
```python
Copy code
@handle_exceptions
def divide(a, b):
    return a / b
divide(10, 0)  # Выведет: Exception occurred: division by zero
```
В этом примере декоратор handle_exceptions перехватывает исключение ZeroDivisionError, возникающее при делении на ноль, и выводит соответствующее сообщение.
Важно отметить, что декораторы не изменяют исходную функцию, а добавляют к ней дополнительное поведение. Это может быть полезно при обработке исключений, так как позволяет ограничить повторяющийся код для обработки исключений в разных функциях.
